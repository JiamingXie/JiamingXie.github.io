<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[学习笔记190117]]></title>
    <url>%2FJiamingXie.github.io%2F2019%2F01%2F17%2F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0190117%2F</url>
    <content type="text"><![CDATA[个股 三安光电： 公司化合物半导体收入只有千万级别，进展不如预期，产品价格可能超预期下降 存货比例太高，有大幅度减值风险，LED芯片景气度也面临下降 如何关注地雷？ 注意那些一家独大的大股东，也就是第一大股东和其他股东的股权相差太多。这样的公司往往丧失了经营的自主权，资金很容易被大股东侵占。从以往的案例看，很多公司账面资金虚高背后都隐含着大股东侵占公司资金的事实。 注意高现金高负债并存，大存大贷的公司需要特别警惕。尤其是公司长期存在大额货币资金，需要对其货币资金真实性存疑。 更换会计师事务所的公司要小心。更换会计师事务所并不一定代表企业报表存在问题。但是不少造假企业在报表披露前都出现过更换会计师事务所的现象，所以这也是一个预警。 消息面 下午，商务部发言人在新闻发布会上称，应美国财长姆努钦、贸易代表莱特希泽邀请，中国国务院副总理刘鹤将于1月30日至31日访美，就中美经贸问题进行磋商。 上海带量采购要求未中选品种降价10%～30% 。 按照上海的要求，在“4+7”带量采购中未中选的最高价药品，将根据其与同品种中标价的差额大小，降价10%～30%。 医药股短期内好不了，一方面是因为之前估值太高，另一方面就是因为政策利空。 盘面 两市早盘震荡回升，尾盘出现小幅跳水。到收盘，沪指跌0.42%，深成指跌0.93%，创业板指跌1.25%。个股上涨家数只有五分之一，热点凌乱，创投概念再度活跃。 今天市场收跌，创业板指数跌幅较大。创投概念、煤炭、西安自贸区、燃料电池、石油等概念板块涨幅居前，语音技术、微信小程序、电子发票、仪器仪表等跌幅居前。个股涨跌比713:2742，自然涨停30家、跌停4家。 板块方面，煤炭板块领涨，软件、军工等板块领跌。外资今日继续流入28亿，但本轮反弹以来，两市融资余额持续减少。内外资的一退一进，也使得反弹，显得一波三折。 行业方面 防守端不受经济下滑影响的必需消费品方向——调味品、免税、化妆品、养猪，个别不受医保控费影响的医药股。 进攻方向，仍是逆经济周期的高景气度方向——5G、云计算，择机布局锂电。 市场缺乏热点，只炒超跌股，没有好的标的 持仓配置从三季度，经济确认加速下滑开始。持仓逻辑： 防守：牛市配可选消费，因为其业绩弹性大；熊市配必需消费，因其业绩有保障。 进攻方向：高景气度，一直是熊市获得超额收益的主要方向。关于这一点，我也讲过，包括08年在内的多轮熊市中，大幅跑赢指数的板块特征——行业高景气度。 偏主题的白马股，股价表现最好的阶段，是在利好的朦胧期，这时候，虽看不见利润，但大家的预期，无限美好。等到了业绩兑现期，因为之前太乐观，利润释放总是低于预期，而高点时的企业盈利，又总是难以持续，更是让炒作步履艰难。 近期看到了，业绩下调的养猪股，股价表现，总是强于业绩上调的养鸡股；招投标中的特高压，和尚未开启招投标的5G，却总是强于医疗信息化等方向。 长期高景气的方向：云计算，买谁看云转型进展情况；锂电，买谁看子行业竞争格局改善情况。]]></content>
      <categories>
        <category>股市观察日记</category>
      </categories>
      <tags>
        <tag>Stock Analysis</tag>
        <tag>Technical Analysis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习笔记190116]]></title>
    <url>%2FJiamingXie.github.io%2F2019%2F01%2F16%2F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0190116%2F</url>
    <content type="text"><![CDATA[盘口 昨天大涨之后，两市今日窄幅震荡。个股涨少跌多，两市涨跌幅中位数为-0.27%。板块方面，热点凌乱，银行、煤炭领涨，贵金属、券商领跌。北上资金，全天流入28亿，主要流入方向仍为白酒和家电。 天津自贸区、石墨电极、国产软件、煤炭、医药等涨幅居前，边缘计算、特高压、证券、福建自贸区、白酒等跌幅居前。个股涨跌比1306:2066，自然涨停28家，跌停2家。 消息面/信息披露 董明珠再度当选为格力董事长。投资者，对价值股最大的要求，是稳定经营和分红的预期。虽然投资人对董，略有不满，但家电目前还是消费股中比较好的选择 康得新炸雷，刷爆资本圈。账上明明放着150亿，却生生还不起十亿债券。 康得新以前是做光学膜的，如何生产、市场需求如何，都很清晰 现在做新材料，很多是军民融合，能否转化成业绩难以捉摸 像虚拟现实和碳纤维，都很难转化成业绩 虚拟现实，需要以5G商用为基础；而碳纤维业务，国内一直是投产的多，达产的少，产品一直在低级阶段徘徊 现金造假，存贷比不合理（手握巨额现金，却还到处借贷） 上海机场(600009)1月16日晚披露的数据显示，2018年12月，公司旅客吞吐量为602.2万人次，同比增长3.33%；货邮吞吐量32.3万吨，同比下降4.75%；飞机起降42854架次，同比增长1.40%。 由中央结算公司主办的“2019年债券市场投资论坛”在京召开。财政部国库司副主任郭方明在会上表示，准备研究将国债与央行货币政策操作衔接起来，同时扩大国债在货币政策操作中的运用，推动实施国债作为公开市场操作主要工具的货币政策机制，健全国债收益率曲线的利率传导机制，强化国债作为基准金融资产的作用，使国债达到准货币的效果。 财新报道，从接近央行人士处获悉，国债无风险、流动性好，被监管视为优质流动性资产，但并不是清偿手段和支付工具，与通常意义上讲的货币存在明显差距，更不是所谓的“准货币”；第二，央行已经采取了一系列逆周期调节措施，目前流动性保持合理充裕，为实体经济提供了足够的金融支持，没有必要通过QE的手段大规模投放流动性。]]></content>
      <categories>
        <category>股市观察日记</category>
      </categories>
      <tags>
        <tag>Stock Analysis</tag>
        <tag>Technical Analysis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[stock]]></title>
    <url>%2FJiamingXie.github.io%2F2019%2F01%2F15%2F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0190115%2F</url>
    <content type="text"><![CDATA[新闻/信息披露 李克强总理主持国务院会议，审议《政府工作报告（征求意见稿）》 提到，今年我国发展的环境更加复杂，困难挑战更多，经济下行压力加大，政府工作艰巨繁重。创新和完善宏观调控，坚持不搞“大水漫灌”，通过实施区间调控、定向调控精准发力，依靠改革开放激发市场活力，依靠市场活力顶住下行压力，保持经济运行在合理区间。进一步优化营商环境，加快发展壮大新动能，突出重点补短板，培育扩大国内市场。 【言下之意就是下行压力大，提前做出一些反应】 *ST长生收到深交所《关于对长生生物科技股份有限公司股票实施重大违法强制退市的决定》，于16日起复牌 【5%的涨跌停限制，多少炒作的人又要死在跌停板上】 上海三毛公告称，由于房地产交易市场不活跃，公司位于深圳两处住宅房产降价近200万后仍无人竞买，公司拟终止前述两项房产的挂牌事宜，该房产已经撤牌。 今天，财政部部长助理许宏才表示，2019年，还要进行进一步的深化增值税改革，继续推进实质性的减税。具体的增值税改革方案，现在还在研究论证和测算过程中，但肯定会有实质性的减税措施。方案将按程序审议后公布实施。【未来的方向，低税率，严查】 张一鸣（今日头条创始人）、王欣（快播创始人）、罗永浩（锤子手机创始人）选择在今天同时推出社交产品。【一个能打的都没有】 今天，据华南某券商机构业务部人士向记者透露，该公司即将对量化私募放开其股票交易系统接口。【利好券商，利好量化公司】 午间，发改委副主任表示，将聚焦人工智能、工业互联网、物联网等的建设，加快5G商用步伐。5G作为新型信息高速公路的作用，将会凸显，大量新型应用会爆发。人工智能、工业互联网、物联网方面，将涌现大量牛股。 而所谓工业互联网，第一步是数据采集，第二步是海量数据上云，第三步是APP控制和应用。相当于给云计算，加了一层数据采集。从这个角度来看，也同时利好云计算的IaaS、SaaS、PaaS层相关企业。 除了上述三个方向，5G的商用，会加速电动车时代的到来。别再认为，开电动车是为了省油了，国家扶持的目的是确保能源安全。而需求爆发的原因，在于电动车相当于给智能手机加了4个轮子，汽车变成电子产品，Model 3的历史意义，不亚于当年的第一代iPhone。 2018年12月末，我国广义货币（M2）余额182.67万亿元，同比增长8.1%（上月8.0%）；狭义货币（M1）余额55.17万亿元，同比增长1.5%（上月1.5%）。 M1≈银行体系以外的现金+企事业单位的活期存款 M2≈M1+企事业单位的定期存款+居民存款 M2可以通俗地理解成国家印钞的速度。比如，2018年12月M2同比增长8.1%，意思就是与2017年12月相比，国家印出来的钱，又增加了8.1%。 盘面 指数反弹渐入佳境，机构回补蓝筹板块，指数再度推升，上证50涨2.03%，沪指涨1.36%，深成指涨1.86%，创业板指涨1.63%。个股涨多跌少，板块方面，酿酒、券商、保险、工业互联网概念领涨，昨日涨幅居前的煤炭、钢铁收绿。 年关将至，食品类消费股的行情可能已经到来 白酒板块涨价的原因：外因自然是北上资金的发力，内因则是白酒企业和投资者预期快速降低后，面对基本面真空期，板块有预期修复的需求。]]></content>
      <categories>
        <category>股市观察日记</category>
      </categories>
      <tags>
        <tag>Stock Analysis</tag>
        <tag>Technical Analysis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[190114学习笔记]]></title>
    <url>%2FJiamingXie.github.io%2F2019%2F01%2F14%2F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0190114%2F</url>
    <content type="text"><![CDATA[交易技巧短线盯盘关注： 涨幅榜 涨速榜 昨天复盘找出的潜在买入标的 持仓股，今天的潜在卖出标的 昨天的连板股 墨菲法则 如果某件事有可能变坏的话，这种可能性就会成为现实。 假定你把一片干面包掉在你的新地毯上，这片面包两面都有可能着地。但是，假定你把一片一面涂有果酱的面包掉在新地毯上，常常是带有果酱的一面着地。 而在交易中，“墨菲法则”的表现形式则是：你如果想提前知道哪些交易有可能遭受损失，这类交易就包括： 那些你不曾建立保护性止损的交易，或者 由于不谨慎而持有过多的头寸，超过了你应该持有的头寸。 为了避免“墨菲法则”对交易的负面影响，克罗建议，我们应当坚持： 无论何时要为所持有的头寸建立保护性的止损； 为每个合约的金额（包括所有合约的累计金额）规定一个上限，而且无论在何种情形下都不要超过这个数。 然后，克罗认为，要想步入股票、期货交易“赢家圈子”的行列，需要遵循以下基本策略： 只参与那些行情趋势强烈或者说行情主要走势正在形成的市场； 把头寸建立在当前行情主趋势的适度逆行位置上； 当你的追市头寸形成有利变动时，坚持持有该类头寸； 一旦所持有头寸的变动方向对你有利，你可以在某些特定条件下增加所持有的头寸。 同时，克罗强调：尽管投机成功最重要的因素是一致的、可行的策略，此外还需要3个增加的重要内容：约束、约束，还是约束。 基本面新基建 主要有五个方向 5G基站建设 18年开展试点，19年试商用，20年正式商用 产业链：基站天线、射频器件、小基站、光纤光缆、PCB、主设备、光模块 特高压 18年能源局印发《关于加快推进一批输变电重点工程规划建设工作的通知》，加快推荐9项重点输变电工程建设，12条特高压工程将于今明两年给予审核。 城际高速铁路和城市轨道交通 电动汽车充电桩 新能源浪潮下的蓝海 大数据中心 集中存放计算机服务器的地方 新闻/信息披露 美的集团公告，预计2018年盈利198亿元–208亿元，比上年同期增长15% - 20%。 亚洲金融论坛上，银保监会副主席王兆星表示，房地产市场既不要过热也不要过冷，最好是保持相对稳定。因为无论房地产市场过热还是过冷，都会对经济和金融带来很大的负面影响。银保监会所有的信贷政策都是致力于促进房地产市场稳定健康发展，同时保障低收入群体的住房需求。所以，既要防止泡沫，也要防止房地产出现大的波动。 中国国家外汇管理局周一在网站上发布公告称，合格境外机构投资者(QFII)总额度增加一倍至3,000亿美元。这是这一额度自2013年7月从800亿美元增至1,500亿美元之后，首次获得上调。彭博汇编的数据显示，海外机构目前动用的额度约为1,010亿美元。 【外资的注入将有助于提振陷入困境的中国资本市场–在全球主要基准指数中，上证综合指数去年的表现忝陪末座。】 海南省政府企业家咨询会议成立大会暨第一届年会在海南三亚召开。成立大会确定阿里巴巴董事局主席马云、腾讯董事会主席马化腾、中化集团董事长宁高宁、北京大学教授周其仁、携程董事会主席梁建章为首届咨询会议成员，推选马云担任咨询会议首任主席、马化腾担任咨询会议副主席。 【这是在协助海南完成改革开放试验区的重大历史任务。】 发改委副主任连维良表示今年在投资上将聚焦五个方面： 一是加强新型基础设施建设，推进人工智能、工业互联网、物联网等建设，加快5G商用步伐； 二是加强城乡基础设施建设，推进市政、物流基础设施建设，加快脱贫攻坚、农村基础设施建设； 三是加强能源、交通、水利等重大基础设施建设； 四是加强民生和公共服务能力建设，推进养老、健康、教育等补短板投资力度； 五是加强生态环保和自然灾害防治能力建设。“改造”，就是加大制造业技术改造和设备更新。 进出口数据 按美元计，中国12月进口同比-7.6%，预期4.5%，前值3%；出口同比-4.4%，预期2%，前值5.4%。 出口下降→产能过剩→人民币下跌 对美出口回落，主要是因为iPhone出口大幅减少；自美进口回落，则是因为半导体景气度下滑，导致集成电路进口减少。 对欧、日、新兴经济体的出口，也大多出现了不同程度的下滑，反映外需正面临冲击。此外，进口的回落，显示内需也同样不景气。 盘口 今天跌幅居前的计算机和民航，都属经济后周期行业。简单说，就是经济下滑一段时间后，该行业需求和基本面开始向下。以计算机行业为例，因为多为信息化公司，一旦下游企业确认经济开始下滑，首先会削减IT开支。 大航企前期客座率，一度击穿80%，达到历史较低水平，油价下滑的利好被对冲掉了。而现阶段，航空股容易反弹，则是因为春运旺季到来，客座率会出现大幅回升，同时受益油价下跌、汇率上涨。但只是反弹，而非反转。源于旺季之后，客座率再度下滑，不可避免。]]></content>
      <categories>
        <category>股市观察日记</category>
      </categories>
      <tags>
        <tag>Stock Analysis</tag>
        <tag>Technical Analysis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Graphic Programming]]></title>
    <url>%2FJiamingXie.github.io%2F2018%2F12%2F04%2FGraphic%20Programming%2F</url>
    <content type="text"><![CDATA[Introducing GUISo far our program has been console program. Which runs in a command window. It did not know how to: Show or handle graphics Process mouse events Let user type in an window Provide a list box, or a drop down Give multiple choices with check boxes • Give single choice with radio buttons And many more using Graphical User Interface (GUI). It is about time. Java provides multiple different ways to build solid GUI application (desktop application and applets as well). One of the oldest way is by AWT (Abstract Window Toolkit).API Another way is using SwingAPI. AWT (Advanced Window Toolkit): is a java package which can be used in any Java program. import java.awt.*; It provides many classes to be used for different OS, or as applet in browser. Adequate for many applications. It uses controls defined by your OS: it uses the lowest common denominator for portability. It is lighter and faster. Good way to start learning GUI. Swing: Similar concept as AWT. Newer than AWT. More controls to make richer GUI (JSlider, JColorChooser, JSpinner) import javax.swing.*; Many of the common controls are used in both: AWT Buttons Frames CheckBox Label Swing Jbuttons Jframes JCheckBox JLabel 12345678import java.awt.*;class TestGraphics &#123;public static void main(String[] args) &#123; //A frame with "Title", "Minimize Bottom", "Maximize Bottom", "Close Bottom" Frame newFrame = new Frame(); newFrame.setSize(550, 200); newFrame.setVisible(true);&#125; &#125; Your application usually first displays something. So, you need a Frame or Dialog to display (e.g. text, image, input/output widgets – called components) You arrange these components using layout. All these components interact with each other to solve your programming needs.They listen to each other, so, you need to attach listeners to these components. When an user interacts with these components an event is generated by OS and captured by listening components. Container:A container holds and displays Components. Examples of container include: Panel,Window and Frame Component: Components are widgets you use to get input/output from users. Examples of component include: Checkbox, Label, Scrollbar, Menu,TextField *Remember that a Container is also a Component. This is a clever way to nest containers. Frame: A frame is a subclass of Container class. It has a title bar and a border around. You can create multiple components and add to a container like Frame. 1234final Frame frame = new Frame();final TextField textField = new TextField("Hello World"); frame.add(textField);frame.setSize(550, 200);frame.setVisible(true); All container has common functionality – as they are derived from Component. Container provides event-handling methods. All containers have these functionalities: add(Component) remove(Component) getComponents() setLayout(LayoutManager) getLayout() Layout Manager: Use a layout manager to arrange components inside a Container. 123456789101112Frame content = new Frame("This is an introduction to graphics programming"); content.setBackground(Color.CYAN);content.setLayout(new FlowLayout());content.add(new Label("Day1:"));content.add(new Button("Monday")); content.add(new Label("Day2:")); content.add(new Button("Tuesday")); content.add(new Button("Wednesday"));...content.add(new Checkbox("Check Me")); content.add(new TextField("Write Here", 30)); content.setSize(550, 200); // width, heightcontent.setVisible(true); LayoutManager: Is a abstract class, you must subclass it or use these derived classes (More Layout Managers): BorderLayout: Arrange in North, East, Center,West, South direction (maximum five comonents) 12345content.setLayout(new BorderLayout()); content.add(new Button("Monday"), BorderLayout.NORTH); content.add(new Button("Tuesday"), BorderLayout.WEST);content.add(new Button("Wednesday"), BorderLayout.CENTER); content.add(new Button("Thursday"), BorderLayout.EAST);content.add(new Button("Friday"), BorderLayout.SOUTH); CardLayout: Like tabbed dialogs GridLayout:Arrange in grid of fixed size. Components are placed in left to right and top to down FlowLayout: Default frame layout. Arrange in a row and aligned, place on new line when needed Event HandlingJava GUI and Windowing systems use the event-driven model to interact with the user. OS is constantly polling for these events. When it finds one, it tells you the (program), what just happened. You can chose not to care about that event, in that case, OS handles with default behavior, or you (your program) do something with that event – you can take it and ignore it as well. What are these events? A window is closed, maximized, minimized A mouse is moved, clicked or dragged A button is clicked A value is selected from list box A radio button is pressed A text is typed in a text box All of these generates events and OS first grabs it and then sends to those components which generated it. How do you handle them in Java GUI? Most components (button, textbox), already handle some events, e.g. button click, check mark display. Components send the event and listeners listen for such event. Different components send different event You can attach a listener to a component to associate an action with a component. Window: Handle a window close event. 123456789Frame content = new Frame("This is a frame");content.add(new Button("Monday"), BorderLayout.NORTH); content.addWindowListener( new WindowAdapter()&#123; //add a listener//inner anonymous classpublic void windowClosing(WindowEvent e) &#123;System.exit(0); &#125;&#125; ); Window: Implement WindowListener and define the method windowClosing 123456789class TestGraphics extends Frame implements WindowListener &#123; public TestGraphics(String s) &#123;addWindowListener(this); // listen for events on this Window&#125;public void paint(Graphics g)&#123; g.drawString("Hello World", 100, 100);&#125;// define methods in WindowListener interface public void windowClosing(WindowEvent event) &#123; System.exit(0);&#125; Button: You need a ActionListener, which must have a matching actionPerformed(ActionEvent) method 123456789publicTestGraphics(String s) &#123; add(pushButton); pushButton.addActionListener(this);&#125;// define action for Button presspublic void actionPerformed(ActionEvent event) &#123;if (event.getActionCommand().equals("Click Me")) &#123;System.out.println("ouch!");&#125;&#125; &#125; TextField: You need a ActionListener – waiting for enter key pressed, which must have a matchingactionPerformed(ActionEvent) method. A TextListner listens for any and all keys. This requires a textValueChanged method implemented 12345678910111213final TextField textfield = new TextField("Type something"); textfield.setEnabled(true);textfield.setEditable(true);textfield.addTextListener(new TextListener() &#123;public void textValueChanged(TextEvent e)&#123; System.out.println(textfield.getText());&#125; &#125;);frame.add(textfield);frame.setSize(550, 200); frame.addWindowListener(new WindowAdapter() &#123;public void windowClosing(WindowEvent e) &#123; System.exit(0);&#125; &#125;); Graphics: Use this abstract class for drawinggraphics. 123456drawString(str, x, y);drawRect(x1, y1, width, height);drawRoundRect(x1, y1, width, height, arcWidth,arcHeight);drawRect3D(x1, y1, width, height, raised);Image img = getImage(getDocumentBase(),“hello.gif”); g.drawImage(img, 0, 0, this);]]></content>
      <categories>
        <category>Java for Dummies</category>
      </categories>
      <tags>
        <tag>coding</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Input/Output & Collection]]></title>
    <url>%2FJiamingXie.github.io%2F2018%2F11%2F27%2FInput%3AOutput%20%26%20Collection%2F</url>
    <content type="text"><![CDATA[Exception Handling (Advanced)Java bundles the information regarding that exception in a class which are derived from Throwable, it then creates that object and throws to the offending methods which caused it. Java allows ways to catch such exception object in your code to handle in graceful way or throw back to the method which called your method. If you don’t do exception handling, then you need to consider all the exception conditions. Use try and catch to design your program. All Java exceptions extends the class Throwable. Error and Exception are two subclasses of Throwable. Error: You rarely do anything with Error as they are internal java resource error Exception: You generally deal with Exception and its subclasses RunTimeException and IOException. RunTimeException : Happens due to error in your code-array out of bounds, type mismatch etc. IOException: Out of your code. BAD URL or a file read. All exceptions derived from Error and RunTimeException are called unchecked exceptions. All other exceptions like IOException are called checked exceptions and Java enforces you that you handle them in some way. Five keywords used in Java for exception: try: block for offending code catch: block to catch exception throw: to throw exception manually. Java throws system generated exception automatically. throws: use to describe a method which throws an exception out. finally: block executed after try with our without catch. checked exception: Strictly enforced by java. If a method throws checked exception then, you could: Either catch the exception and handle in some way, or You can simply declare it using throws and let it pass through your method, or You can map it to your own exception class 123method-type method-name(parameters) throws exception-list&#123; &#125; 123456789101112void method1&#123; try&#123; method2();&#125;catch(Exception e)&#123; &#125;&#125;void method2() throws Exception&#123; method3();&#125;void method3() throws Exception&#123; throw new Exception();&#125; 1234567891011121314151617public static int getInput(Scanner in) throws NullPointerException&#123; int userChoice=0; if(in==null)&#123; throw new NullPointerException("Null Scanner"); &#125; System.out.println("Please enter a value between 1 and 5"); userChoice=integer.parseInt(in.next()); return userChoice;&#125;... try&#123; getInput(inputReader); &#125;catch(NullPointerException e)&#123; System.out.println("Message:" + e.getMessage()); System.out.println("Stack Trace"+ e.printStackTrace()); &#125; You can only throw only those exceptions which you have declared in the throws clause of method declaration or the subclass of that exception. If you cannot find a suitable exception class in the library, you can create your own exception. 12345678910111213141516171819//write your own exceptionclass MyOutOfRangeException extends Exception&#123; MyOutOfRangeException(String message)&#123; super(message); &#125;&#125;public static int getInput(Scanner in) throws NullPointerException, MyOutOfRangeException&#123; int userChoice=0; if(in==null)&#123; throw new NullPointerException("Null Scanner"); &#125; System.out.println("Please enter a value between 1 and 5"); userChoice=integer.parseInt(in.next()); if(userChoice&lt;1 || userChoice&gt;5)&#123; throw new MyOutOfRangeException("Please enter a value between 1 and 5"); &#125; return userChoice;&#125; Java Input/OutputA lot is done for us by the API: java.lang.package. It contains three predefined public static stream variables, in, out, and err. System.out and System.in refers to standard output(screen/console), and standard input(keyboard). File Class: import it from java.io Use this to work with the disk file in operating system. It has many useful methods which will allow you to work on a file. Find out if it exists using exists method Find out if you can read or write using canRead , canWrite Delete the file using delete Find the size using length Find it’s full path with getPath You typically use File class in conjuction with other classes. 12345File myFile = new File(fileName);if(myFile.exists())&#123; System.out.println("File name is:" + myFile.getName()); System.out.println("File is: "+ myFile.getAbsolutePath());&#125; You can use File class with Scanner just like you used System.in 12345678910111213141516Scanner readInput;try&#123;readInput = new Scanner(new File(fileName)); while(readInput.hasNextLine()) &#123;System.out.println(readInput.nextLine()); &#125;&#125;//start with most specific to most general exceptioncatch(FileNotFoundException e)&#123; System.out.println("File: " +fileName + "not found");&#125;//end catchcatch(IOException e)&#123; System.out.println("Error Reading from file: "+fileName +e.getMessage());&#125;catch(Exception e)&#123; System.out.println(e);&#125; There are many choices for I/O in JAVA. Java and most other I/O are stream-based. A stream is really a connection to a source of information or to a destination of information. An input stream may be associated with a keyboard or a disk file, and an output stream may be associated with a screen or a disk file. A program can have multiple streams: console, disk files, keyboard, sockets, memory, strings What do you do with stream? You first open the stream use the stream to read data sequentially, write or both, and then finally close them. There are two types of streams in Java: ​ Byte streams to read/write binary data ​ Character streams to read/write Unicode characters Byte stream: There are two abstract classes on top: InputSteam and OutputStream. There are many concrete classes which implements the behavior to read and write. 123456789//How big is the file?InputStream inStream;inStream = new FileInputStream(args[0]);int total=0;while(inStream.read()!=-1) total++;System.out.println(total + "bytes");inStream.close(); System.in , System.out and System.err are predefined byte stream. Character stream: There are two abstract classes on top: Reader and Writer. There are many concrete classes which implement the behavior to read and write. Text File I/O using Character Stream: Output: Use PrintWriter, FileWriter(FileOutputStream) Input: Use BufferedReader, FileReader You will use sets two of classes for easier reading and writing. Buffered Reading/Writing: In most system including Java most of the time, the input/output streams are buffered before it is physically written into the disk file. By doing this OS conserves the overhead, as accessing disk is inefficient compare with memory(RAM) access. Stream Names： Java needs to work with the OS while dealing with streams. [Your program connects to OS by JDK] Every file has two names: input final.txt is what OS uses while inputStream is what Java uses. Use stream which can be used for Input e.g. FileReader 12FileReader fileReader = new FileReader("filename");//input OS filename “filename” name of OS file (store in your hard drive) going forward your code will only use fileReader FileReader provides a way to read an integer at a time. If it goes to the last character of the text file, the xx.read() will be -1. 1fint readInput= ileReader.read(); 1234FileReader fileReader = new FileReader("input_final.txt");int readInput;while((readInput=fileReader.read())!=-1) System.out.println("Byte: "+readInput+"\tChar:" (char)readInput);//Change byte to ASCII code Reading from Input Stream: Using BufferedReader Use .readLine to read a line into a String (.read() for single char) No methods to read numbers, so, use Tokenizer to parse String. 1234567891011try&#123; FileReader fileReader = new FileReader("input_final.txt"); BufferedReader finallnStream = new BufferedReader(fileReader); String s; while((s=finallnStream.readLine())!=null)&#123; System.out.println(s); &#125; finallnStream.close; //remember to close it&#125;catch(Exception e)&#123; e.printStackTrace();&#125; Reading from console(System.in): Console provides byte of stream so, reading from Console, i.e. System.in requires you to read characters. (one at a time). This will change the byte stream to character stream and read each individual character InputStreamReader cReader=new InputStreamReader(System.in) You need a BufferReader to read like tokens(individual unit) BufferdReader tokenReader = new BufferedReader(cReader) Read a line(token) : there are methods for word and char String getLine = tokenReader.readLine(); You can parse numbers from these using parse methods of each type, i.e. int myInt=Integer.parseInt(getLine); Writing to Console(System.out): Good thing is System.out already defined to print numbers and strings. System.in should be used with Scanner, but System.out can be used individually. Tokenizer: Most of the time, reading a line is not what you want. However, you want to extract individual elements from it. For that Java provides tokenizer concept. Use StreamTokenizer to read from a stream and StringTokenizer to extract the tokens from a string in your program. Steps in using StreamTokenizer: You need to first create a tokenizer and connect with BufferedReader. Then loop through to get first token, translate the token to your appropriate data and use it, and continue until there is no token left. When you call the tokenizer method nextToken, it returns a flag about the next token: TT_EOF: indicates that the next token is the end of file TT_EOL: indicates the next token is the end of the line TT_WORD: indicates the next token is a word TT_NUMBER: indicates the next token is a number 123456789101112131415StreamTokenizer myTokenizer = new StreamTokenizer(bufferedReader);//start to get next tokennextToken = myTokenizer.nextToken();//it returns a flag previously mentionedwhile(nextToken!=StreamTokenizer.TT_EOF)&#123; if(nextToken!=StreamTokenizer:TT_EOL &amp;&amp; nextToken == StreamTokenizer.TT_WORD)&#123; strToken = myTokenizer.sval;//used to parse the variable System.out.println("Found a string:" + strToken); &#125; if(nextToken!=StreamTokenizer.TT_EOL &amp;&amp; nextToken == StreamTokenizer.TT_NUMBER)&#123; numberToken=myTokenizer.nval; System.out.println("Found a number: "+ numberToken); &#125; nextToken = myTokenizer.nextToken();//keep on going to the next one&#125; Using StringTokenizer: StringTokenizer allows you to parse a string in different tokens. It has an easier way to specify delimiters - compared with StreamTokenizer 123456String getLine = "This is, \n a string. with four delimeters";//create a tokenizer with multiple delimitersStringTokenizer parseWords = new StringTokenizer(getLine,"\n.,");while(parseWords.hasMoreTokens())&#123; System.out.println(parseWords.nextToken());&#125; StringTokenizer can also be used with console System.in 12345678Scanner keyboard = new Scanner(System.in);String getUserInput = keyboard.nextLine();//create a tokenizer with multiple delimitersStringTokenizer parseUserInput = new StringTokenizer(getUserInput,"\n.,");while(parseUserInput.hasMoreTokens())&#123; System.out.println(parseUserInput.nextToken());&#125; Output Using String: Similar to Input Stream. Here also we have two names: outputStream in the program and the physical file name used by OS: output-final.txt You typically connect a text file to a stream for writing: 123FileOutputStream txtStream = new FileOutputStream("f.txt");//OS namePrintWriter textPrintStream = new PritWriter(txtStream); Use println, print, format, flush, close of PrintWriter 123456789101112PrintWriter textPrintStream = null;//do this out of try and catch because you need to close itString outfileName = "output-final.txt";try&#123; textPrintStream = new PrintWriter(new FileOutputStream(outfileName)); textPrintStream.println("This output will go to the file" + outfileName); textPrintStream.write("This is Final Grade \n");&#125;catch(FileNotFoundException e)&#123; System.out.println("Error opening the file" + outfileName + "\n" + e.getMessage()); System.exit(0);&#125;textPrintStream.close();System.out.println(outfileName + "been written and closed."); Collection/ GenericsCollectionJava Data Structures: Java provides systematic way of organizing collections of data. Array: An array is a collection of objects in Java.Array name is reference to the actual object itself. Array of primitive data types: int [] myIntArray = new int[4]; //is array of 4 integer Array of objects: 1234567Box [] myBoxArray = new Box[10];// is array of 10 Box objects – Java objectsmyBoxArray[0] = new Box(2, 3);myBoxArray[1] = new Box(5 10);myBoxArray[1] = new Box(“I am fancy”);myBoxArray[1] = new Box(20, 30,“I am fat and fancy”); ... Java provides an Array class which provides static methods to manipulate the array-for both primitive and ref. sort(): for sorting binarySearch(): for efficient searching Java Arrays: Java Arrays: are type safe simple implementation easy to manipulate good to store collection of primitive and references However, they are not most efficient: Size is constant Inserting and deleting elements are costly Java provides even richer set of data structures to store collection of primitive data and references. For example ArrayList class:A program written to use ArralyList collection would look like this: 12345ArrayList listOfValues = new ArrayList(); listOfValues.add("John"); listOfValues.add("Jack"); listOfValues.add("Jill"); System.out.println(listOfValues); System.out.println("3:"+ listOfValues.get(2)); It looks like array, however, it is much more flexible – as you notice the size grows dynamically. Java provides a unified architecture for representing and manipulating collections through collections framework, which contains the following: Interfaces: Abstract data types that represent collections. Implementations: Concrete implementations of the collection interfaces. Algorithms: Methods that perform useful computation like; searching and sorting which work on all implementations of collection interface in a polymorphic way. Benefits of Java Collection Framework: Reduces your programming effort Increases speed and quality of your program Allows interoperability among unrelated APIs Shorter learning curve Shorter design time for new APIs Fosters OOP by software reuse Java Collection Interfaces: Primary means by whichcollections are manipulated Collection: Just group of objects without any assumptions made about the order of the collection, or whether duplicates are allowed or not. Set: No duplicate elements are permitted and may not be ordered List: Ordered collection, duplicates are permitted Map: Key value pair. Each key can only map to one value, no ordering SortedSet: Elements are automatically sorted, either in their natural ordering or by a Comparator object SortedMap: Mappings are automatically sorted by key, either in their natural ordering or by a Comparator object Methods Implemented with Collection Interface acts on individual elements: 12345678910public void clear();public int hashCode();public Iterator iterator();public Object[] toArray();public int size();public boolean isEmpty();public boolean contains(Object o); public boolean add(Object o);public boolean remove(Object elem);public boolean equals(Object o); Methods Implemented with Collection Interface acts on bulk of elements: 1234567public boolean containsAll(Collection coll);public boolean addAll(Collection coll)public boolean removeAll(Collection coll);public boolean retainAll(Collection coll)//Removes from the collection all//elements that are not elements of coll public void clear() //Remove all elements from this collection Java collection framework provides many Implementation (concrete) Classes, for example: ArrayList: Resizable-array implementation of the list interface. LinkedList: Doubly-linked list implementation of the list interface. Better if frequent insertion and deletion is needed. HashSet: Hash table implementation of the Set Interface. TreeSet: Tree implementation of of SortedSet Interface. HashMap: Hash map implementation of the Map interface. TreeMap: Tree implementation of SortedMap Interface Using Collections: List List is an ordered Collection which allows duplicate elements. Just like array, element index starts at 0. List interface adds several methods for an ordered collection Implementation:ArrayList: a resizable-array implementation. Simple to use. Good for frequent scanning, but, not for frequent add/delete 123456789101112ArrayList listOfValues = new ArrayList();//or List listOfValues = new ArrayList(); listOfValues.add("John"); listOfValues.add("Jack"); listOfValues.add("Jill"); System.out.println(listOfValues);System.out.println("3: " + listOfValues.get(2));listOfValues.add(new NewBox(10)); listOfValues.add(new NewBox(20)); listOfValues.add(new NewBox(30)); System.out.println(listOfValues); LinkedList: Uses a doubly-linked list for storage. Not good for frequent scanning, however, good for frequent add/delete LinkedList is a doubly linked list so you have more methods available as: getFirst(), getLast(), removeFirst(), removeLast() 1234LinkedList linkedListValues = new LinkedList();lnkedListValues.addFirst("John"); linkedListValues.addLast("Jill"); linkedListValues.addFirst("Jack"); linkedListValues.add("Kerry"); linkedListValues.addLast("Sarah");System.out.println(linkedListValues) Set: The Set interface extends the Collection interface. does not allow duplicates (contains no new methods) Two Set objects are equal, if they contain same elements. Null is a valid entry (only one null entry is allowed) Objects added to Set, must have equals() defined SortedSet: Extends Set. Elements are ordered in a specific order. Natural order implemented by Comparable interface. Change ordering by using a Comparator object. Two general purpose implementation: HashSet: Stores its elements in a hash table and is fast. Use it for duplicate free set. The objects stored in this set should implement hashCode() method-one is provided by Object may not be optimal. Objects are not physically sorted. Hash Function: Provide unique integers for each object. Each hash integer must map to the same object, and if two objects are equal (using equals method) then they must return same integer. TreeSet: Ordered set uses tree for storage. It allows elements to be added, or removed at any location by following an order. Implements Set, provides an ordered set (uses tree for storage). Add/remove from any location, ordering is preserved. 123456int size();boolean add(Object obj); boolean remove(Object obj); boolean contains(Object obj); Iterator iterator();Object[] toArray(); TreeSet allows you to defined your own sorting through an Comparator object passed during creation. Implement Comparable Interface: If you want to provide a natural ordering for your object. You must implement compareTo(Object o) method. This method should return a +ve, zero, -ve number if this object is less, equal or greater than the Object passed. 123456789class NewBox implements Comparable&#123; public int compareTo(Object o) &#123; //compares area int area1 = ((NewBox)o).height * ((NewBox)o).width; int area2 = height * width; if ( area1 &lt; area2 ) return 1; else if ( area1 &gt; area2 ) return -1; else return 0; &#125; &#125; 1234567891011NewBox box1 = new NewBox("New Box 3", 10, 20); NewBox box2 = new NewBox("New Box 4", 20, 28); NewBox box3 = new NewBox("New Box 2", 20, 20); NewBox box4 = new NewBox("New Box 1", 25, 20);NewBox[] lotsOfBoxes = new NewBox[] &#123;box1, box2, box3, box4&#125;; for (int i = 0; i &lt; lotsOfBoxes.length; i++) System.out.println(lotsOfBoxes[i].getBoxName());Arrays.sort(lotsOfBoxes); //sort natually - provided by the object for (int i = 0; i &lt; lotsOfBoxes.length; i++) System.out.println(lotsOfBoxes[i].getBoxName() + " Area:"+ lotsOfBoxes[i].getHeight() * lotsOfBoxes[i].getWidth()); However, you may need better sorting, like alphabetical, then implement Comparator Using Comparator Interface: Implement this interface if you want to provide your own comparison.Comparator requires you to implement method: compare() and optionally equals() 12345678910class CompareBoxNames implements Comparator &#123; public int compare(Object s1, Object s2) &#123; //required String str1 = ((NewBox)s1).getBoxName(); String str2 = ((NewBox)s2).getBoxName(); return (str1.compareTo(str2)) ; &#125;public boolean equals(Object s1, Object s2) &#123; //optional String str1 = ((NewBox)s1).getBoxName(); String str2 = ((NewBox)s2).getBoxName(); return (str1.equalsIgnoreCase(str2));&#125; &#125; Application: 1234567891011NewBox box1 = new NewBox("New Box 3", 10, 20); NewBox box2 = new NewBox("New Box 4", 20, 28); NewBox box3 = new NewBox("New Box 2", 20, 20); NewBox box4 = new NewBox("New Box 1", 25, 20);NewBox[] lotsOfBoxes = new NewBox[] &#123;box1, box2, box3, box4&#125;; for (int i = 0; i &lt; lotsOfBoxes.length; i++) System.out.println(lotsOfBoxes[i].getBoxName());Arrays.sort(lotsOfBoxes, new CompareBoxNames()); for (int i = 0; i &lt; lotsOfBoxes.length; i++) System.out.println(lotsOfBoxes[i].getBoxName()); This can easily be used by other Collection objects as well: 123456789101112131415//Use with ArrayListNewBox box1 = new NewBox("New Box 3", 10, 20); NewBox box2 = new NewBox("New Box 4", 20, 28); NewBox box3 = new NewBox("New Box 2", 20, 20); NewBox box4 = new NewBox("New Box 1", 25, 20);ArrayList lotsOfBoxes = new ArrayList(); lotsOfBoxes.add(box1); lotsOfBoxes.add(box2); lotsOfBoxes.add(box3); lotsOfBoxes.add(box4);System.out.println("In the order of creation:\n"); for (int i = 0; i &lt; lotsOfBoxes.size(); i++) &#123; NewBox nBox = (NewBox)lotsOfBoxes.get(i); System.out.println(nBox.getBoxName()); &#125; Extend to another collection: 1234567891011121314//Continued from previous code block//sort natually - provided by the object System.out.println("\nIn the order of natural sorting:\n");Collections.sort(lotsOfBoxes);//sort by areafor (int i = 0; i &lt; lotsOfBoxes.size(); i++) &#123; NewBox nBox = (NewBox)lotsOfBoxes.get(i); System.out.println(nBox.getBoxName() + " Area: " + nBox.getHeight() * nBox.getWidth()); &#125;System.out.println("\nIn the order of Comparator sorting Implementation:\n"); Collections.sort(lotsOfBoxes,new CompareBoxNames());//sort by namefor (int i = 0; i &lt; lotsOfBoxes.size(); i++) &#123; NewBox nBox = (NewBox)lotsOfBoxes.get(i); System.out.println(nBox.getBoxName() + " Area: " + nBox.getHeight() * nBox.getWidth()); Map Interface: Maps a key to the elements – instead of index HashMap: Implements Map interface, uses hash to get unique key value. SortedMap interface extends Map and maintains its keys in sorted order. TreeMap: Implements SortedMap, uses tree for storage and traversing efficiently. Basic operations: 1234Object put(Object key, Object value); Object get(Object key);Object remove(Object key);int size(); TreeMap: TreeMap does not contain an iterator method. However, it contains Set keySet() method which is used to get the set of keys and then iterate through it. No ordering of the values, the tree is arranged according to he order of keys. TreeSet: TreeSet is more specific than TreeMap. TreeSet values are compared with each other, so, make sure to only put those which can be compared. Guaranteed to keep the elements in ascending order or through Comparator. Iterator: Collection interface defines an iterator method which returns an object implementing the Interator interface Iterator is used to access elements of a collection, without exposing internal details. Order is not guaranteed Iterator Interface: Defines these methods 123public boolean hasNext();public Object next();public void remove() Using Iterator: You can use iterator with any collection class which implements Iterator interface 123456System.out.println("\nUsing Iterator:\n"); //usingIterator it = lotsOfBoxes.iterator(); while(it.hasNext()) &#123; NewBox box = (NewBox)(it.next()); System.out.println(box.getBoxName()); &#125; GenericsEnhanced for Loop: New syntax is more compact, and it is easier to use with collection:for (variable-type variable-name: range-of-values) 123456789101112//enhanced for loopint [] weeklyTemp = &#123;69, 70, 71, 68, 66, 71, 70&#125;;//instead offor (int day=0; day &lt; weeklyTemp.length; day++)System.out.printf("The temperature on day %d was %d\n", day+1,weeklyTemp[day]);System.out.println();//use thisint day=0;for (int dayTemp : weeklyTemp)System.out.printf("The temperature on day %d was %d\n", ++day, dayTemp); System.out.println(); Introducing Generics: Generic allows generalized Types. Generics abstract over Types and provides readability and type safety during compile time You can use generics with Methods, Classes and Interfaces as well Use the “&lt;&gt;“ characters to designate the type to be used Generics Rationale: Suppose you needed to write a method to find out if an array contains a certain value (integer for example), then you would write like this: 123456public static boolean contains(Integer [] array, Integer intObject) &#123; for (Integer value : array) &#123; if (intObject.equals(value)) return true;&#125;return false; //did not find it &#125; You will write the same function again for other objects, for example String 1234567public static boolean contains(String [] array, String strObject) &#123; for (String value : array) &#123; if (strObject.equals(value)) return true;&#125; return false; //did not find it &#125; Now with generics, you need to write only one method, use an abstract type T: 12345public static &lt;T&gt; boolean contains(T[] array,T anyObject) &#123; for (T value : array) &#123;if (anyObject.equals(value)) return true;&#125;return false;&#125; 1234567891011121314151617Integer[] array = new Integer[5]; for (int j = 0; j &lt; 5; j++) &#123; array[j] =j * j; &#125;if (contains(array, new Integer(16))) &#123; System.out.println("Found the value");&#125; else &#123;System.out.println("Value not found");&#125;String[] strArray = new String[5]; String strTemp;for (int i = 0; i &lt; 5; i++) &#123;strTemp = String.format("This is string %d", i*i); strArray[i] = strTemp;&#125; if (contains(strArray, new String("This is string 18"))) &#123; System.out.println("Found the value"); &#125; else &#123; System.out.println("Value not found"); &#125; Generics Types: All collection classes are re-written to accommodate Generics 12345678910111213interface List&lt;E&gt; &#123; void add(E x);Iterator&lt;E&gt; iterator(); &#125;interface Iterator&lt;E&gt; &#123; E next();boolean hasNext(); &#125;interface Map&lt;K,V&gt; &#123;V put(K key,V Value); &#125; Generics:Allows compile time type safety. Here is ArrayList example. This is true for rest of the collections as well. 12345678910111213//Before:ArrayList lotsOfBoxes = new ArrayList(); lotsOfBoxes.add(box1); //add more boxes....for (int i = 0; i &lt; lotsOfBoxes.size(); i++) &#123;NewBox nBox = (NewBox)lotsOfBoxes.get(i); System.out.println(nBox.getBoxName());&#125;//After:ArrayList&lt;NewBox&gt; lotsOfBoxes = new ArrayList&lt;NewBox&gt;(); //add more boxes ..for (int i = 0; i &lt; lotsOfBoxes.size(); i++) &#123; NewBox nBox = lotsOfBoxes.get(i);//no castingSystem.out.println(nBox.getBoxName()); &#125;]]></content>
      <categories>
        <category>Java for Dummies</category>
      </categories>
      <tags>
        <tag>coding</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Advanced Object Oriented Programming]]></title>
    <url>%2FJiamingXie.github.io%2F2018%2F11%2F12%2FAdvanced%20Object%20Oriented%20Programming%2F</url>
    <content type="text"><![CDATA[Encapsulation &amp; Access ControlHiding the internal state of an object is known as data encapsulation. Field declaration can be preceded by different modifiers to provide different level of access to that field: Access control modifiers (public, private, protected and default/package) Static Final Access modifiers can be applied to field, method and even class Access Modifier: You can completely encapsulate a member (field or method) by using the private keyword. You can achieve a lesser degree of encapsulation by using the access modifiers protected or public. 1234567public class Box&#123; public Box()&#123;&#125; //everywhere class is accessible int hSize; //default accessibility = package int vSize; //also known as Package Friendly members protected char flChar; //in subclasses as well, private to others [it is available to subclasses] private String name; //accessible only in the class[not available to subclass]&#125; static: There is only one copy of static variable exists to share among all objects of this class. That is why a static member can be accessed without an instance of a class. Also known as class variable 12345678910public class Box&#123; static private int hSize; //I must use static method to get access to static variable static public gethSize()&#123;return hSize;&#125; static public String name="I am a box"; &#125;//outside world where the Box class is accessibleint horizontalSize = Box.gethSize();String boxName=Box.name; You don’t need an object to get that variable. You just need the class. final: Many times you need a variable whose value should not be changed. You can make: a reference a method a class a vairable a final. Initializing final variable: Usually the final variables are initialized right where it is declared, however, you can differ that for run time - blank-final. (you don’t need to assign the value when the variable is initialized.) 12345678910111213class Box&#123; final int hSize; int vSize; Box(int h)&#123; //you want the user to decide what should be the value of the constant hSize=h; vSize=10; &#125; public void SethSize(int h)&#123; hSize=h;//you cannot do this, because hSize has been set through the constructor. &#125;&#125; Final and reference types: If you make a reference as final then this reference can’t refer to any other references. 1234567final Box defaultBox= new Box();Box bigBox=new Box(20,30);defaultBox=bigBox; //error- defaultBox is finalbigBox=defaultBox;defaultBox.vSize=20;// OK; box reference is final, not members Final method arguments: You can have a method arguments which are final. A final method cannot be overridden in subclasses. 1234public void setvSize(final Box b)&#123; b=new Box(5);// error- b is final b.vSize=20; //fine, b is final, the member of b is not final&#125; Final class: A final class can no longer be in herited to create subclasses. All methods of a final class is implicitly final. this keyword: Java has a concept of referring to itself (same object). You use this keyword in same object to refer itself. You can use them for: Resolving name conflict where the field name and method arguments are same. 1234567public class Box&#123; private int hSize; public sethSize(int hSize)&#123; hSize=hSize; //Error this.hSize=hSize; &#125;&#125; To pass reference to the current object as a parameter to other methods 123456public class Box&#123; private int hSize; Box(int hSize)&#123; Box(this);//call another constructor &#125;&#125; Initializer in Jave: It is block of instructions which are performed right after the fields that are created and just beforet the constructors are called. This is confusing though, so a constructor is a better way to initialize fields. 1234567891011public class Box&#123; //you can initialize like this int h=10; int w=20; String hC="-"; String vC; static String boxName; &#123;vC="$";&#125; //static initializer static &#123;boxName= "Default Box";&#125;&#125; Method overloading: A class can have more than one method with the same name as long as they have different parameter list. Compiler calls the right method by matching the name and parameter lists. 123456public void changeDimension(char vChar)&#123; &#125;public void changeDimension(char vChar, int vSize)&#123; &#125; You can also overload constructors as well. Demo: 12345678910111213141516171819202122232425262728293031323334353637383940package utility;public class OOPBox&#123; //blank-final final int hSize; int vSize; //int height=10; //it can also be initialized in this way //int width=20; String hChar="*"; String vChar; static String boxName; &#123; vChar="%"; //you can also initialize the variable by putting it in the block. //should be put before the constructor &#125; static &#123; boxName="I am an OOPBOX." &#125; OOPBox(int h)&#123;//this is the constructor hSize=h; vSize=10; //default value //initializer &#125; public void sethSize(int h)&#123; hSize=h; //error. because it has been already assigned in OOPBox before &#125; public static void main(String[] args)&#123; final OOPBox defaultBox= new OOPBox(10); //set defaultBox as final OOPBox bigBox = new OOPBox(5); OOPBox smallBox; smallBox = defaultBox;//OK defaultBox = smallBox; //Error. defaultBox is final defaultBox.vSize=20; //OK. coz vSize is not final &#125;&#125; Override and Overload 12345678910111213141516171819202122232425262728293031323334353637383940414243//Superclasspublic class Box()&#123; public void drawYourself()&#123; //default drawhLine(hSize,hString); System.out.printf("\n"); drawvLine(hSize,vSize,fillerStr,vStr); drawhLine(hSize, hStr); System.out.printf("\n"); &#125; //subclass public class FancyBox extends Box&#123; public void drawYourself(int howBig)&#123; super.sethSize(super.gethSize()*howBig); super.setvSize(super.getvSize()*howBig); super.drawYourself(); &#125; //Override drawYourself public void drawYourself&#123; drawhLine(super.gethSize(),super.gethStr()); System.out.print("\n"); drawvLine(super.gethSize(),super.gethSize(),super.getFillerStr(),super.getvStr()); drawHLine(super.gethSize,super.gethStr()); System.out.print("\n"); &#125; &#125; //Overload - Same method name but different parameters public FancyBox()&#123;//default constructor must be offered &#125; public FancyBox(int hSize, int vSize, String hStr, String vStr, String fillerStr)&#123; super(hSize,vSize,hStr,vStr,fillerStr); &#125; public FancyBox(int h,int v)&#123; super(h,v); &#125;&#125; InheritanceOne of the advantage of OOP is code re-use Java allows multiple ways for you to re-use already developed and time tested class in your own code. By way of composition: Embed one class into another. Another way is through inheritance. Here one class inherits all the properties of another class. Composition defines ‘has-a‘ relationship. When you add a reference to another class you are already using the composition. 1234public class Box&#123; int height; String name;//this class use string class&#125; Here Box ‘has-a’ String, so we are already using composition relationship. Inheritance defines ‘is-a‘ relationship. Process of inheriting state and behavior from another class Every class in java has one and only one parent Only object class has no parent if you don’t derive a class from another, it is implicitly derived from java.lang.Object class You can have a chain of derivations What is a Subclass？ Sub-class can be thought of as a class which also contains(like in composition) the superclass. During the creation of Fancy Box, a Box of object needs to be created as well, and Box needs to be created first. Use keyword extends to derive one class from another. Inheritance is always public, there is no access modifier for it. You can access base class functionality by using super keyword. Derived class can call the base class constructors by using super keyword (it has to be first instruction.) You have to call base constructor which exists if the base class does not have an empty constructor. 123456789101112public class Box&#123; public Box()&#123;&#125;;//you must define this, or super(); will fail in subclass public Box(int hSize,...)&#123; &#125;&#125;public class FancyBox extends Box&#123; public FancyBox()&#123; super();//it calls Box()&#123;&#125;; &#125;&#125; Abstract ClassAbstraction: It is the modeling, representation of an element of the problem domain in a program. Abstraction is the process of identifying and grouping attributes and behavior of an entity. Allows architect to focus on important attributes. Abstract method: Java allows you to declare an object without defining it first: Box b; Similarly java allows you to declare a method without really defining it - meaning without body public abstract void draw();//missing{} draw is called abstract method. Abstract class: A class which has at least one abstract method is called an abstract class. 12345678910abstract class myBox&#123; public void getHeight()&#123; return hHeight; &#125; public void setHight(int h)&#123; hHeight=h; &#125; public abstract void draw(); // we want this method to be implemented by a concrete class&#125; Abstract class provides an empty class, with empty behaviors and kind of enforce that this class can only be used for inheritance and not for instantiating any objects as this object can’t do anything. 12345678910111213abstract public class Shape&#123; public Shape()&#123;&#125;; abstract public void draw(); abstract public String getName();&#125;public class Box extends Shape&#123; public Box()&#123;&#125;; public void draw()&#123; System.out.println("Complete."); &#125; public String getName()&#123;return name&#125;;&#125; 123456Shape myShape = new Shape(); // it is not allowedShape yourShape = new Box();//this is allowed. //You can assign the reference, but not create it.String strName=yourShape.getName();Box defaultBox = new Box(); //you can create Box class InterfaceA Problem: At times during design you will run into a situation where you wish you could provide a uniform functionality across different classes, which may not be directly related by inheritance. Java does not allow inheritance from multiple classes, so they provide interface mechanism which comes very close to multiple inheritance. Interface is really a promise to outside world to guarantee a certain behavior by a class which will implement this interface, a contract. While there are differences, however, interface is very much look like abstract class. You declare an interface using a keyword interface, give it a name and its members. Interface can have three types of members: Constant fields Methods Nested classes and interfaces 12345public interface IShape&#123;//put I here to say it is an interface public void draw(); //it contains method signatures without body public void setFillCharacter(String str); //all methods are abstract, so no need to specify abstract&#125; Interface can have only named constants, public, static, final. It can have only abstract methods, however all these modifiers are omitted by convention. 123456public interface IDog&#123;//implicitly abstract. can have a public/package/(default) modifier int LIFE_EXPECTANCY =15; int MAX_SPEED =30;//implicitly public, void and final void fetch();//methods are implicitly abstract and public void wagTail();//they cannot be final or static&#125; You cannot instantiate an interface interface is implemented by a class or extended by another interface a concrete class implements all the interfaces. Abstract class can implement part of the methods. Ultimately all methods need to be implemented in the hierarchy of derivation chain. Interface allows classes to implement certain behavior irrespective of their locations in the class hierarchy. One class can implement several interfaces, providing a way for multiple inheritance. A class implements an interface by providing concrete methods； 123456public class Dog implements IDog&#123; private String name; private String breed; void fetch()&#123;System.out.println("Fetch");&#125;//concrete methods void wagTail()&#123;System.out.println("Wag Tail");&#125;&#125; If you want to implement multiple interface: You can write a concrete class which can extend one super class. 123456789public class Dog implements IDog, IAnimal&#123; private String name; private String breed; void walk()&#123; System.out.println("Walk.");&#125;//Dog and Animal void fetch()&#123; System.out.println("Fetch");&#125;//Dog void wagTail()&#123;System.out.println("Wag tail");&#125;//Dog&#125; Just like classes, interfaces can be inherited also and can have hierarchy, even though interface is not party of class hierarchy. 123456public interface IK9 extends IDog&#123; int SERVICE_LIFE =5; int TOP_SPEED=40; void attack(); void findPeople();&#125; Interface Releases(how do you version it?): Once the interfaces are made public, any changes made in the interface itself will break the original contract. 123456789public interface IDog&#123; int LIFE_EXPECTANCY =15; int MAX_SPEED=30; //methods are implicitly abstract and public //they can't be final or static void fetch(); void wagTail(); void wait();//will break all callers using IDog before&#125; You can always write a new interface by extending the old one. This will allow the old code work just fine, and whoever has knowledge of new interface will implement the newer version. 123public interface INewDog extends IDog&#123; void wait();&#125; You cannot instantiate an object from an interface. When you define a reference variable of interface type, they must be assigned to an object of the class that implemented that interface. 1IBox iP4 = new IBox(); //Error instanceof operator: Allows you to find out if a reference is a type of particular interface or a class. 12345678public class K9 extends Dog implements INewDog, IK9&#123;...&#125;Dog myLab = new K9();//Then all these followings are going to be true:myLab instance of DogmyLab instance of K9myLab instance of INewDomyLab instance of IK9 The use of instanceof is not really recommended. You may be able to improve your design. Advantages of Interface: used for encapsulation/flexibilities Allows implementation changes without affecting the caller Unrelated classes can implement similar behavior Allows multiple inheritances]]></content>
      <categories>
        <category>Java for Dummies</category>
      </categories>
      <tags>
        <tag>coding</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Class, Exceptions, Scope]]></title>
    <url>%2FJiamingXie.github.io%2F2018%2F10%2F23%2FClass%2C%20Exceptions%2C%20Scope%2F</url>
    <content type="text"><![CDATA[Class1int myAge=12; Literally myAge is an object whose state is value 12. The behavior of myAge can be “add”, “substract”, “compare”, etc. Concept of objects are applied to new type of objects created by programmers where built in objects (data types) are not sufficient to solve the need. Users have requirements Identify nouns to make up the class Verb/adj make up behavior and state Organize classes to solve users’ requirement Object’s state is stored in fields(variables) it could be primitive data type or another object 123456public class Box&#123; int width = 20; int height = 10; String hLineSymbol= "-"; String vLineSymbol= "|";&#125; Object’s behavior is defined by methods(functions) it operates on internal state. Hides details. Providing OOP Encapsulation. 12345678void changeHLSymbol(String hLine)&#123; hLineSymbol=hLine;&#125;void changeVLSymbol(String vLine)&#123; vLineSymbol=vLine;&#125; Demo 12345678910111213141516171819202122232425262728293031class Box&#123; //state int hSize=10; int vSize=20; String hChar="-"; String vChar="|"; String fillerStr = " "; //behavior void drawHLine(int h, String hStr)&#123; int i=0; while(i++&lt;h) System.out.print(hStr); &#125; void drawVLine(int h, int v, String hStr, String vStr)&#123; int i=0,j=0; while(i++&lt;v-2)&#123; System.out.print(vStr); drawHLine(h-2,hStr); System.out.println(vStr); &#125; &#125; void drawYourself()&#123; //default box drawHLine(hSize, hStr); System.out.printf("\n"); drawVLine(hSize,vSize,fillerStr,vStr); drawHLine(hSize,hStr); System.out.printf("\n"); &#125;&#125; 12Box defaultBox= new Box();defaultBox.drawYourself(); Restrict access to data within class Use visibility modifiers in methods for accessbility to clients (of class) Pass data to/from methods as parameters Create instance variables for class, built in types and use locally or pass as parameters Create helper methods as utility 12345678910111213public class Box&#123; private int width = 20; //private: you can change it without the user knowing about it private int height = 10; //state by variable names private void trimHeight()&#123;&#125;; //hide your state and behavior public void changeHeight()&#123;40&#125;; public void Draw(); //behavior by methods&#125; Class is a template to create an object. Object: A BIG BOX or a small box is an instance(object) of a Box blue print(class) Object is run time entity consisting of data(state) and responds to messages (behavior) 12345678import MyUtility.*;public class FirstJavaHello&#123; public static void main(..)&#123; Box bigBox = new Box(); bigBox.drawBox(); //bigBox is an object and you apply the behavior "drawBox" to it &#125;&#125; An object is an instance of its class(blue print), and the process of creating a new object is called instantiation. bigBox is instantiated from Box class new operator is used to instantiate a new object 1234Box bBox, sBox;//declare variable//create a part of memory for the objectbBox = new Box(); //instantiatebBox.drawBox(); //use bBox is a reference to an box object(bBox is an interface not real object – which is in memory). A box object keeps track of height and width. What is the value of height and width of new object? Use accessor methods! 1234bBox.findHeight();bBox.findWidth();bBox.findVLSymbol();bBox.findHLSymbol(); How do you change these values? Use mutator methods! 1234bBox.changeHeight(8);bBox.changeWidth(8);bBox.changeHLineSymbol("*");bBox.changeVLineSymbol("*"); Always write a special method called: toString as well It is a good habit. Every time you want to dump your output, use this method. 12345678public String toSting()&#123; return "\nName: "+boxName + "\nHeight:" + height+ "\nWidth: "+width+ "\nH Line Symbol: "+hLineSymbol+ "\nV Line Symbol: "+vLineSymbol+ "\n\n";&#125; You can directly call the toString method for that object. However, there are other situations where the method toString is implicitly called. For instance: toString is called implicitly when a Box object is concatenated with a string. toString is called when Box object is in an argument to the method println 12345678String str;str = "This is Johns Big Box: \n" + bigBox.toString();//this is equivalentstr = "This is Johns Big Box: \n" +bigBox;System.out.println(smallBox.toString());//this is equivalent toSystem.out.println(bigBox);//you can directly print Combining state and behavior in a single software entity is called Encapsulation Objects have behavior defined by methods Objects have state because at any moment instance variable has values in them Each object has unique ID handled internally 123456789public class Box&#123; //if you don't want others to know how you draw the box, you can add 'private' private int width = 20; ... private String vLineSymbol = "|"; ... void changeHLSymbol(String hLine)&#123;&#125;; ...&#125; JVM(java virtual machine), Computer Memory and Your Program: Memory holds: ​ compiled class templates(always) ​ variables that refer objects and object themselves ( come and go) in first instantiation, disappears when not needed JVM keeps track of object references Unreferenced objects are deleted via garbage collection Primitive Types, Reference Types and the nullValue: In java there are two fundamental types: Primitive types: byte, char, int, double, boolean etc. (box that contains a value of that primitive type) Reference types: all classes, for instance, String, Student,… (a box that contains a pointer to an object) Reference variables can be assigned the value null which will eventually be garbage collected. Two or more variables can refer to the same object. 123456789101112Box bigBox, smallBox;bigBox = new Box();//the reference is copied to bigBoxsmallBox = bigBox;//bigBox and smallBox are pointing to the same place.System.out.println(bigBox);System.out.println(smallBox);//you can break the connection by assigning null to itsmallBox=null;//you can only assign null to objects but not primitive variables//int i=null; //cannot be done Demo 12345678910111213141516171819202122232425262728293031class Box&#123; //state private int hSize=10; private int vSize=20; private String hChar="-"; private String vChar="|"; private String fillerStr = " "; //behavior private void drawHLine(int h, String hStr)&#123; int i=0; while(i++&lt;h) System.out.print(hStr); &#125; private void drawVLine(int h, int v, String hStr, String vStr)&#123; int i=0,j=0; while(i++&lt;v-2)&#123; System.out.print(vStr); drawHLine(h-2,hStr); System.out.println(vStr); &#125; &#125; public void drawYourself()&#123; //default box drawHLine(hSize, hStr); System.out.printf("\n"); drawVLine(hSize,vSize,fillerStr,vStr); drawHLine(hSize,hStr); System.out.printf("\n"); &#125;&#125; We need to provide a public mutator or accessor. source -&gt; Generate Getters and Setters... Eclipse can automatically create the methods for you. 123456789101112//accessor method//get the parameterpublic int gethSize()&#123; return hSize;&#125;//mutator method//change the parameterpublic void sethSize(int hSize)&#123; this.hSize = hSize; //'this' means the hSize represents the hSize for this class&#125; 1234567891011121314151617181920212223Box defaultBox = new Box();//Box() means you are calling a constructor.//It's name is the same as the classdefaultBox.drawYourself();//How to create a constructor?public Box()&#123; &#125;public Box(int hSize, int vSize, String hStr, String vStr, String fillerStr)&#123; super(); this.hSize=hSize; this.vSize=vSize; this.hStr=hStr; this.vStr=vStr; this.fillerStr=fillerStr;&#125;//Then you can directly set the parametersBox smallBox= new Box(25,10);Box bigBox= new Box(30,15,"&amp;","+","#");bigBox.drawYourself(); Eclipse can help you generate the constructor Source -&gt; Generate Constructor using Fields... Error Handling Syntax errors: compiler will report this error Semantic error: logical error - compiler has no clue Runtime errors: logical error which crashes your program Divide by zero Subscript out of range for arrays Stuffing wrong data type Calling a function on null object … How can you fix it? Syntax errors: With help of compiler and document Logical errors: by debugging and not doing sloppy programming Runtime errors by using exception handling Errors in JavaUse the function which checks error for us: 1234567Box bigBox, smallBox;bigBox = new Box();int boxSize = getValidInteger();bigBox.ChangeHeight(boxSize);bigBox.changeWidth(getValidInteger()); Exceptions in JavaWhen you program crashes for some situation which JVM doesn’t know how to handle, JVM will create a special object called exception and throw. As a programmer, it is up to you to catch that exception object and handle the situation relatively gracefully. 123456789smallBox= null;try&#123; smallBox.drawBox(); //try block. Trying to do something which could go wrong&#125;catch (Exception e)&#123; //control is transferred here if any exception is raised in try block System.out.println("Something wrong with drawing smallbox: "+ e);//you can have many catch block&#125; Demo123456789import java.util.InputMismatchException;...;try&#123; tempArray[day]=getInput.nextInt();&#125;catch(InputMismatchException e)&#123; System.out.println("Problem reading your input: "+ e.getMessage());//Print your error(here is "Null") getInput.next(); //gobble up the old input stream //The scanner will start from the next variable&#125; If you want to re-enter after typing a wrong input, then you should add a loop outside: 1234567891011int day;for(day=0;day&lt;tempArray.length;day++)&#123; System.out.printf("Enter the temp: "); try&#123; tempArray[day]=getInput.nextInt(); &#125;catch(InputMismatchException e)&#123; System.out.println("Problem reading your input: "+ e.getMessage() + ". Please re-enter: "); getInput.next(); day--; //reset the day so that you can re-enter the temperature&#125;&#125; Scope and life time of variablesClass ConstructMost classes have similar constructs A name with some modifiers Some instance variables One or more method describing how to initialize the object (Constructors - method) A constructor is a special method with the same name as the class More methods which signifies how your object responds to messages Constructor is called when you use new operator Used for initializing the state of newly instantiated object Can have multiple constructors Default Constructor has empty body If you don’t provide, JVM provides one Default Constructor If you have multiple constructor, you can chain them 123456789public class Box&#123; private int width =20; ...; public Box()&#123;&#125;; public Box(int w, int h, String hLine, String vLine, String boxName)&#123;&#125;; ...; private void drawHoriontalLine(); public void drawBox();&#125; Class has two main parts: Instance variables Methods When a new object is created it will have its own new set of instance variables (Global Variables)(common pool of data for all methods) Object: contains data and responds to messages Class: has template to create object and has code When a method executes - it does for an object it has complete access of instance variables and local variable Scope of Variables Scope is region of program where the variable is visible Scope of parameter and local variable is restricted to the methods Scope of instance variable(global variable) is all methods of the class Compiler will flag it as error if you go out of scope 12345678Block scope&#123;&#125;&#123; int myInt=20;&#125;//Variables in different blocks&#123; int myInt=50;&#125; Life Time of VariablesThe time period during which the variable can be used Local variables: Single execution of method Formal parameter: Single execution of method (new value for the next call) Instance(global) variable: Available during life time of object Recycling (duplicating) the variable names: Is allowed because of scope resolution will take care of this issue Good usage of: Instance variable Be careful not to use it for other purposes Parameter Local variable Don’t use to remember state of object (local variable goes out o the scope when the method is done) Class Hierarchy in JavaJava has hierarchy of classes. Object is the base of this hierarchy. A class immediately after another class is called subclass(child) of its superclass(parent) All classes in Java has one parent and many children(except Object class) A new class in the hierarchy will inherit commonality of its parent class(superclass) You use extend keyword to extend the base class If you omit extend, it automatically inherits from Objects Inheritance: Different kinds of objects have commonality and differences: Some additional features Mountain bikes have gears, while mountain bikes also have two wheels like road bikes. Specialized objects inherit the commonality from other classes Subclass inherits commonality from superclasses class SolidBox extends Box{...} Demo: Use packages. 12345package utility;public class Box&#123; ...;&#125; 123import utility.*;Box defaultBox=new Box(); When you are creating new Class, you can add package and superclass. 12345678910111213141516171819202122232425262728293031package utility;public class FancyBox extends Box&#123; private String boxName = "Default Fancy Box"; //The following two blocks can be generated by eclipse public String getBoxName()&#123; return boxName; &#125; public void setBoxName(String boxName)&#123; this.boxName=boxName; &#125; @Override public void drawYourself(int howBig)&#123; super.sethSize(Super.gethSize * howBig); super.setvSize(Super.getvSize * howBig); super.drawYourself(); &#125; public FancyBox()&#123; &#125; public FancyBox(int hSize, int vSize, String hStr, String vStr, String fillerStr)&#123; super(hSize, vSize, hStr, vStr, fillerStr); &#125; public FancyBox(int h, int v)&#123; super(h,v); &#125;&#125; 123import utility.*;FancyBox fbox=new FancyBox(); Interitance: Source →Override/Implement Methods →drawYourself choose the methods that you want to override.]]></content>
      <categories>
        <category>Java for Dummies</category>
      </categories>
      <tags>
        <tag>coding</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[反思]]></title>
    <url>%2FJiamingXie.github.io%2F2018%2F10%2F23%2F%E8%82%A1%E5%B8%82%E8%A7%82%E5%AF%9F%E6%97%A5%E8%AE%B0181023%2F</url>
    <content type="text"><![CDATA[好久没有更新了。 简单点评一下最近的股市。 因为上周末的利好刺激所以周一股市大涨了，券商板块全部涨停，上一次还是14年牛市的时候，还是很新奇的。其他板块也被带动大涨，看得出这一波的龙头就是金融股了。 周二马上迎来回调，虽然回调力度不大，白酒砸盘厉害。我个人觉得这反而是个不错的信号，等这波白马止跌了，那么底部就差不多了。 整体上来看，上周五和这周一的行情是暂时的反弹行情，虽然可以持续一段时间但是真正的底部还没有出来。政策底出来之后还有一段时间才会出市场底，而后是基本面底部。所以这波没有参与到问题也不大，之后还有回调的机会。政策底之所以先于市场底出现，是因为没有政策利好刺激，大盘还得跌。对于判断不准的情况也可以分批建仓，现在已经是明确的底部区间了，无非不知道这还要持续多久，可能还需半年才能走出底部。金融股中的强势股估计回调力度不大，仅仅是横盘整理，等整理完毕后，必然向上突破带头冲锋。 最近其实每天都看很久的盘，而且要操作，有点累了，所以都没写总结。发现自己交易的时候心态还是很差的，经常咋咋呼呼的，没法完全遵循自己的交易原则。其实只要好好遵循自己的交易逻辑，就不太容易亏钱。我自己也亏了一些，这几天每天都在反思这个问题。有时候能判断盘面形式了，交易的手完全不跟着脑子走。 希望自己以后交易都能遵循以下原则： 价值投资的股，只要不深套，就不要出手 只在下跌时买进（现在技术不好，拒绝追涨战术），只在上涨时卖出（除了止损的情况外） 剩下的以后再加吧… 当交易员没有一颗强大的内心是不行的，最好能像机器人一样没有感情。博弈的时候，就算做错9次决策，第十次还是要去做。涨跌都只是数字而已，不要频繁操作，追涨杀跌。]]></content>
      <categories>
        <category>股市观察日记</category>
      </categories>
      <tags>
        <tag>Stock Analysis</tag>
        <tag>Technical Analysis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[今天的我是一个有福气的我]]></title>
    <url>%2FJiamingXie.github.io%2F2018%2F10%2F16%2F%E4%BB%8A%E5%A4%A9%E7%9A%84%E6%88%91%E6%98%AF%E4%B8%80%E4%B8%AA%E6%9C%89%E7%A6%8F%E6%B0%94%E7%9A%84%E6%88%91%2F</url>
    <content type="text"><![CDATA[今天收到了一个包裹，里面是雪媚娘和麻薯。 咦，我从来没有买过这个东西呀？问了妈妈，妈妈也说不是她寄的。 完了，万一人家寄错了，不小心吃了还得赔，赶紧去问问。 … 陆铁柱：是谁寄的呀 我：不知道呀。我从小到大都没人对我这么好过，谁寄的我就嫁给谁。 … 赶紧发了一条票圈向全世界发问，到底是哪位好心人给我寄的好吃的。 阿鱼：大傻砸 我：你寄的吗？？ 阿鱼：好吃吗？ 我：QAQ嗯（虽然我还没吃到）你怎么对我这么好 阿鱼：发工资了，就想请你吃好吃的。 我：QAQ TAT那你回来我也请你吃大餐。从小到大还没人对我这么好呢。 阿鱼：你好好吃吧，我先去准备明天的考试了。 … 我好像，从小都没有被人献过殷勤，也没有人对我有什么特殊的情愫，所以对这些事情都特别敏感，一旦发生就会感动到稀里哗啦以至于奋不顾身。那一句“是谁寄的我就嫁给谁”是发自肺腑的真心话，没准哪一天哪个人对我好了我就分分钟跪倒膝下被收入囊中。不知道这是好是坏，也不知道所谓的我的2018的桃花到底是哪里来的，毕竟2018只剩两个半月了。]]></content>
      <categories>
        <category>生活杂记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[杀跌继续，反弹即将到来]]></title>
    <url>%2FJiamingXie.github.io%2F2018%2F10%2F16%2F%E8%82%A1%E5%B8%82%E8%A7%82%E5%AF%9F%E6%97%A5%E8%AE%B0181016%2F</url>
    <content type="text"><![CDATA[盘面分析 三大指数平开，开盘之后中小创表现颓势，个股一度杀跌猛烈，随后权重板块开始企稳回升，上证50一度大涨，创业板也被带动翻红，但好景不长，中小创开始单边回落，午后三大股指毫无回暖迹象，以炭黑、铁矿石为首的资源板块跌幅居前，加之题材概念的杀跌，市场再度全线翻绿，创业板一度跌3%，仅银行板块上涨，临近尾盘，大盘弱势盘整。截止收盘沪指跌0.85%，深成指跌1.95%，创业板指跌2.68%，均创出调整以来新低。 沪指 深指 创业板 今天的热点是金融股和天然气（公用事业），资金净流入最多的板块是保险和银行。明天估计金融股歇息一下，之后要拉升的时候再出马。 连续两天的下杀一下子把股民们都吓傻了（虽然大家都习惯了，这叫回调），但是其实今天下午应该算是看到机会了。 这两天的操作思路如下： 首先昨天进场的时候应该选择今天有机会冲高的龙头股。 可以看到大概10点半左右的时候东财跳水，到10：45左右开始横盘，东财这两天会出三季度预告，所以不能重仓，万一业绩不及预期就会跌。早盘轻仓介入以后，中午出了三季度预告，虽然不及预期，但是好于大部分券商，下午如何走要看各个投资者的解读。下午开盘的时候上突非常猛烈，说明市场还是比较看好的，这个时候就可以拿着手上的仓位躺倒了。下午因为受到大盘拖累所以没有走出非常好的走势，不过已经强于大盘了。 到了今天，因市场悲观气氛浓厚，个股会继续阴跌，所以应该在早盘冲高的时候出货，等到下来再接回。 金融股经过今天一天的拉抬，之后资金需要休息一下，但是之后大盘整体的反弹和拉升，还是需要金融股的力量。 再来看另外一只基建的龙头股，中国铁建。 中国铁建在基建股里属于老大哥的存在，每次需要护盘或者拉行情总有它的身影。 熊市的时候总要有几个板块出来捍卫一下大A的尊严，基建就是其中之一，而铁建是基建的龙头。 这位哥这几天也是很惨了，补跌跌了约莫有10个点了。 那么如何看出它要启动了呢？首先是看大盘，大盘今天的走法是横跌横跌横，跌无可跌，跌到位了。其次是铁建这两天的补跌是投资者的一个判断，他们判断这种时候市场不适宜做多，但是其实大盘已经差不多没有下跌空间了，他们意识到自己犯错误了，所以要把铁建的股价干回去。第二个判断是铁建下午的走势，在上午放了几波量（长色绿柱）以后，下午铁建的走势明显要好于大盘，而且上突欲望还是比较强烈的。当看到铁建两次站稳的时候，就可以考虑在10.70~10.75之间建仓了。虽然之后又有小幅下跌，但是那是受到还在加速杀跌的地产股和医药股的拖累。 炒股的收益本质是你在别人做错判断的时候不慌不忙抄底，在别人疯狂时不慌不忙卖出，所以对局势的判断是至关重要的。铁建的机会就在于，投资者做错了判断，铁建的杀跌是不合时宜的，所以要干回去。 明天的早盘有可能会走出两种走势，一种是直接高开并且震荡上行；另外一种是先再下杀一波然后红盘。比较强势的股可能会走出前面那种走势，而较弱的走后面那种走势，不管是哪种走势，明天的早盘一定是追涨策略（只要有低价筹码就是机会），看谁涨得好就干谁。周五收红，站上2600。]]></content>
      <categories>
        <category>股市观察日记</category>
      </categories>
      <tags>
        <tag>Stock Analysis</tag>
        <tag>Technical Analysis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[A股弱势下跌后上演V形反弹，创业板带头冲锋]]></title>
    <url>%2FJiamingXie.github.io%2F2018%2F10%2F14%2F%E8%82%A1%E5%B8%82%E8%A7%82%E5%AF%9F%E6%97%A5%E8%AE%B0181012%2F</url>
    <content type="text"><![CDATA[盘面分析 受外盘影响，两市小幅低开，随后在民航板块的带动下，三大指数一度翻红，但此后指数随即回落，两市一度再现杀跌，随后白马股逐渐企稳，指数也随即回升，午后两市延续午前的走势，题材蓝筹稳步走强，创业板一度涨逾1%，上证50则大涨2%，市场在经历了连续的大幅杀跌之后，抄底资金开始逐渐入场，目前市场总体回暖，临近尾盘，横盘震荡。 截至收盘，沪指收报2606.92点，涨0.91%，成交额1428亿；深成指收报7558.28点，涨0.45%，成交额1661亿；创业板收报1268.41点，涨0.52%，成交额472亿。沪指本周下跌7.6%，创下八个月最大单周跌幅。 带头冲锋的板块主要是白马蓝筹和高送转。 主力净流入行业板块前五：银行、电子制造、食品加工、保险、机场主力净流入概念板块前五：次新股、中字头、装配式建筑、互联网保险、超级品牌主力净流入个股前十：格力电器、中国平安、万科A、东方财富、伊利股份、雅运股份、恒瑞医药、平安银行、中国铁建、超频三 龙头股的走势非常典型，不随大盘下跌，分时DDX强势走高，说明资金进入意愿十分强烈。 东财下午的时候横盘了很久，但是完全不虚，因为从买卖档口可以看到有大单一直在10.6吃单。股价一直不破10.58。周一可以高抛低吸，降低成本。 沪指本周哐叽了两次，其实是很大程度受到了外围的影响的。贸易战加码和美联储加息，说对中国没影响是不可能的，很有可能还是长期的影响，比如国产软件、国产芯片公司。这种影响可能会在接下来的几年里体现出来。]]></content>
      <categories>
        <category>股市观察日记</category>
      </categories>
      <tags>
        <tag>Stock Analysis</tag>
        <tag>Technical Analysis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[受外围影响，千股跌停再现]]></title>
    <url>%2FJiamingXie.github.io%2F2018%2F10%2F11%2F%E8%82%A1%E5%B8%82%E8%A7%82%E5%AF%9F%E6%97%A5%E8%AE%B0181011%2F</url>
    <content type="text"><![CDATA[盘面分析 在连续两天收出星以后，A股开盘低开3.7个点，之后一蹶不振，指数毫无反抗，个股单边下行，市场不足百家个股上涨，市场超3300只个股下跌，午后两市稳步走弱，沪指跌破2600点关口，超1000只个股跌停，仅50只股票上涨，三大股指一度均跌6%，临近尾盘，大盘弱势震荡。截至收盘，沪指收报2583.46点，至近四年新低，跌5.22%，创逾31个月最大单日跌幅，成交额1701亿；深成指收报7524.09点，跌6.07%，成交额1886亿；创业板收报1261.88点，跌6.30%，成交额538亿。 看来之前一直讨论的“熔断底”并不是真正的底部，A股要企稳还有很长的路要走。 入行几个月，一直受到熊市的摧残，现在已经有了非常强大的内心，一个交易员应该不为情绪所影响，时时刻刻都保持冷静，不因为盈亏影响自己的判断。今天的这种形势，对广大持股股民来说，是一种灾难，但是同时也是一种机会。 在国庆回来看到暴跌的情况下，就不应加仓了，这样的市场状态并不是可以介入的状态。这几天的暴跌是外围对A股的影响，也是股民对未来的一种预期。美联储加息导致大量资金从股市撤出，企业借贷成本上升，这对经济基本面来说是不向好的，对于股市中的上市公司来说也是不利的。另外美国与墨、加签订明显针对中国的协定，虽然中国现在国力强盛，但是还是有非常多的产品依赖进口，试问如果现在美国断掉我们的芯片供应，我们的电子产业不会受到巨大冲击吗？国产的芯片、软件股是热点，他们是带领反弹呢，还是带头砸盘呢？科技股受到外部的强烈打击，还需要等一等，最终有它们站出来的时候。从夏天观察到现在，科技股的龙头有好几支，用友、浪潮、恒华等等，但是最近都被杀到妈都认不得了，今天更加是好几支跌停，但是也不排除有被错杀的，短线反而是机会。 大盘一直走弱，在这个过程中基本面好的，不断走强的股票才是好股票，大盘一直砸出最低，但是这些股票都不创新低了，都是具有配置价值的股票。在经济基本面不向好的时候，应该多配置一些刚需的板块，比如消费和医药，因为人饿了得吃饭，生病了得吃药。为什么之前消费降级被炒得很热，榨菜股方便面股几个月翻了翻，因为股民的钱都被套了，大家没钱消费啊，拉动GDP要靠什么？要靠消费。有人问现在茅台都这么高了还能买吗？当然能买，茅台是好公司，五粮液也是好公司，只是之前涨太高了，这半年都跟着其他白马一起被杀。医药板块，最近的消息是有好几款抗癌药进了医保，一些龙头公司也有利好，开始研发新药，之后的走势应该会发生分化，强者恒强，所以这类股票就要看准龙头买（恒瑞医药、片仔癀等）。当然有时也要靠基建，基建之前站出来过几次（中国建筑、中国铁建、中国交建），之后什么时候站出来，还是个未知数。还有什么股票可以配置？三金-保险、银行、券商。这些板块都是国家队大量持有的权重股，风险比较小。一般情况下都是四大美女-基建、三金、科技股、白马轮流唱戏，市场没有热点的时候几块钱的垃圾股也会炒作一下，没有人会知道明天的热点是什么（不过以后用大数据机器学习一下没准是可以预测出来的），盘感好的大牛可以技术面做短线，但是一般的小散还是以基本面价值投资为主，结合短线高抛低吸降低成本为好。 长线来看现在很多资金都在布局，包括长线养老金入市的事情现在也落地了。不过就最近的经济局势，现在抄进去抄到的应该不是真正的底，真正的企稳可能要等到明年下半年。如果要配置绩优蓝筹股，那么现在超跌的时候，就是机会。短线不建议介入，长线可以配置资产，至于已经有仓位的，卧倒不动等大盘企稳再上车，之后应该是漫长的磨底过程。]]></content>
      <categories>
        <category>股市观察日记</category>
      </categories>
      <tags>
        <tag>Stock Analysis</tag>
        <tag>Technical Analysis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Arrays, Methods, Strings, Class]]></title>
    <url>%2FJiamingXie.github.io%2F2018%2F10%2F10%2FArrays%2C%20Methods%2C%20Strings%2C%20Class%2F</url>
    <content type="text"><![CDATA[ArraysSuppose your boss ask you to calculate the average temperature of a week. How can you store seven temperatures? What if you are asked to do for 365 days? What if you are asked to do for 10 years. Array is a data structure which stores multiple values of same type. 123int [] weeklyTemp;...int av_temp=(weeklyTemp[0] + weeklyTemp[1]+...)/7; You use index to apply the element in the array. Index starts from 0. array_name.legth gives the size of array. You can also put a size for the array. 12345int weeklytemp[];weeklytemp = new int[7];weeklytemp[0] = 55;weeklytemp[1] = 54;... 123int tmp[]=&#123;55,54,56,52,51,53,50&#125;;float av_tmp=(tmp[0]+tmp[1]+tmp[2]+tmp[3]+tmp[4]+tmp[5]+tmp[6])/7;System.out.printf("The Average Temperature is: %f", av_tmp); Assigning one array to another actually assigns the references!! Essentially both of them are same array!(mapping to the same memory) 123int lastweektmp[]=&#123;55,54,56,52,51,53,50&#125;;int thisweektmp[];thisweektmp=lastweektmp; when you change lastweektmp, thisweektmp will also changes; vice versa. Use Loop get the sum of … 1234int weeklyTmp[]=&#123;69,70,71,68,66,71,70&#125;;float sum=0.0f;for(int i=0;i&lt;weeklyTemp.length;i++) sum+=weeklyTemp[i]; get the max of… 12345int maxTemp=0;for(int i=0;i&lt;weeklyTemp.length;i++)&#123; if(weeklyTemp[i]&gt;maxTemp) maxTemp=weeklyTemp[i];&#125; get the min of… 123456int min = weeklyTmp[0];int day=0;for(day=1;day&lt;7;day++)&#123; if(min&gt;weeklyTmp[day]) min = weeklyTmp[day];&#125; Comparing arrays Array name is reference. When you compare values (other than built in type) you are comparing the reference. 12int weeklyTmp1[]=&#123;69,70,71,68,66,71,70&#125;;int weeklyTmp2[]=&#123;69,70,71,68,66,71,70&#125;; But weeklyTmp1=weeklyTmp2 is False because they are mapping to different references. Character StringsCharacters in Java Printable and nonprintable Lowercase letters Uppercase letters Numbers Special characters Strings is a sequence of characters not a formal data type into store texts java Strings are objects in java java provides string class to create and use them it is part of every java installation (no import needed) the positions in the strings are enumerated starting with zero String literals are represented by double-quoting the content: “Text”. String class provides many useful methods: int length() return length of string char charAt(int index) returns a char ar index boolean equals(String other) int compareTo(String other) Compares this string &amp; other returns 0 for equal neg if less otherwise pos String substring(int beginIndex, int endIndex) Returns substring String trim() Trim out the blank bolean equalsIgnoreCase(String other) 123456789101112131415char c = 'a';if (Character.isDigit(c)) System.out.printf("%c is a digit\n", c);else System.out.printf("%c is not a digit\n", c);String myString = "Whatever you want to put here";System.out.printf("The length of the string is: %d\n", myString.length());System.out.printf("The character at %d position is %c\n",5,myString.charAt(5));System.out.printf("The index of \"%c\" is at %d position\n",c,myString.index(c,10));//find the character "a" after the 10th characterSystem.out.printf("The part of string starting from %d to %d is %s\n",5,10,myString.substring(5,10)); Unlike arrays, string1=&quot;Hello world!&quot; equals to string2=&quot;Hello world!&quot;. Because they point to the same string. so never use string1==string2 to test the equality. Don’t test the equality of reference!! You should test the method!! string1.equals(string2) If string1=&quot;hello&quot; and string2=&quot;Hello&quot;, then we can use equalsIgnoreCase(). You can also compare the strings lexicographically. The comparison is based on the Unicode value of each character in the strings. The character sequence represented by thisString object is compared lexicographically to the character sequence represented by the argument string. The result is a negative integer if this String object lexicographically precedes the argument string. The result is a positive integer if this String object lexicographically follows the argument string. The result is zero if the strings are equal; compareTo returns 0 exactly when the equals(Object) method would return true. 123456789101112String string1="hello";String string2="Hello";if(string1.compareTo(string2)&gt;0)&#123; System.out.print("String1 is greater.");&#125;else if(string1.compareTo(string2)&lt;0)&#123; System.out.print("String2 is greater.");&#125;else&#123; System.out.print("Both are equal");&#125; MethodsClass and main will get large: unreadable Not maintainable repeated code Method is a snippet of programs working together allows: Code re-use Team development Well structured application Easy maintainance The methods really define the behavior of an object. printf(), nextInt() are all methods. We can also write our own methods. a. Declaration b. Define c. Use (Invoke) General Form method_type, method_name(argument_list); 123456float getBracket()&#123; ...&#125;;void Sum(int,int)&#123; ...&#125;; float and void are different kinds of methods. When you want to call the methods, it is just like when you are using the system methods. Before you use the method, you need to define the method first. 1234static float getBracket()&#123; ... return yourTaxBracket;&#125; Demo 123456789101112131415161718192021222324252627282930313233343536373839404142static void getTemperatures(int [] tempArray)&#123; Scanner getInput = new Scanner(System.in); int day; for(day=0;day&lt;tempArray.length;day++)&#123; System.out.printf("Enter the temp: "); tempArray[day] = getInput.nextInt(); &#125;&#125;static void printTemp(int [] tempArray)&#123; int day; for (day=0;day&lt;tempArray.length;day++) System.out.printf("The temperature on day %d was %d\n",day+1,tempArray[day]);&#125;static int getMin(int [] tempArray)&#123; int min=tempArray[0]; int day; for (day=1;day&lt;tempArray.length;day++)&#123; if (min&gt;tempArray[day]) min = tempArray[day]; &#125; return min&#125;static int getMax(int [] tempArray)&#123; int day; int max=tempArray[0]; for(day=1;day&lt;tempArray.length;day++)&#123; if (max&lt;tempArray[day]) max = tempArray[day]; &#125; return max&#125;static int getTotal(int [] tempArray)&#123; int day; int total = tempArray[0]; for (day=1;day&lt;tempArray.length;day++) total +=tempArray[day]; return total;&#125; 1234567891011121314151617181920212223242526272829303132public class UseBox&#123; static void drawHLine(int hSize; String hstr)&#123; int i=0; while (i++&lt;h) System.out.print(hstr); &#125; static void drawVLine(int h, int v, String vstr)&#123; int i =0; while(i++&lt;v-2)&#123; System.out.print(vstr); int j=0; while(j++&lt;h-2)&#123; System.out.print(" "); &#125; System.out.println(vstr); &#125; &#125; public static void main(String[] args)&#123; int hSize=20; int vSize=10; drawHLine(hSize,"+"); System.out.print("\n"); drawVLine(hSize,vSize,"|"); drawHLine(hSize,"+"); System.out.print("\n"); &#125;&#125; Class and ObjectsJava is a object oriented programming (OOP). All real-world object has state and behavior. Object’s state is stored in fields (variables) it could be primitive data type or another object Object’s behavior is defined by methods (functions) it operates on internal state. Hides details. Providing OOP Encapsulation. A dog object can provide: Age and Name as fields to store state and bark, eat, wagthetail methods for behavior. Benefits: Independent development: Modularity Internal detail is hidden: Encapsulation Reduce redundancy: Code can be re-used Compartmentalizing: Ease of maintainability Class: A blue print to create an individual object. *Red Honda and blue Honda are built in the same factory. There state and behavior are similar. A big BOX or small box is created from same box bue print. 12class Box&#123;&#125; Object: A red Honda is an instance(object) of a generic Honda (class) 12Honda redHonda = new Honda();Honda blueHonda = new Honda(); The behavior is similar but different state. 12345678910Box bigBox = new Box(20,30);//objectBox smallBox = new Box(5,10);bigBox.drawYourself();//behaviorsmallBox.drawYourself();bigBox.changeVLineSymbol("=");bigBox.drawYourself(); Inheritance: Different kinds of objects have commonality and differences: some additional features Specialized objects inherit the commonality from other classes Subclass inherits commonality from superclasses 1class SolidBox extends Box&#123;...&#125; Demo 123456789101112131415161718192021222324class Box&#123; static void drawHLine(int hSize; String hstr)&#123; int i=0; while (i++&lt;h) System.out.print(hstr); &#125; static void drawVLine(int h, int v, String vstr, String hstr)&#123; int i =0, j=0; while(i++&lt;v-2)&#123; System.out.print(vstr); drawHLine(h-2,hstr); System.out.println(vstr); &#125; &#125; static void drawBox(int h, int v, String vstr, String hstr, String fstr)&#123; drawHLine(hSize,hstr); System.out.print("\n"); drawVLine(hSize,vSize,vstr,fstr); drawHLine(hSize,hstr); System.out.print("\n"); &#125;&#125; You can apply the method in Box in other public class 1Box.drawBox(20,10,"|","-","$"); 12Box myBox= new Box(20,10,"|","-","$");myBox.drawBox();//no need for parameters here]]></content>
      <categories>
        <category>Java for Dummies</category>
      </categories>
      <tags>
        <tag>coding</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[陷入僵局]]></title>
    <url>%2FJiamingXie.github.io%2F2018%2F10%2F09%2F%E8%82%A1%E5%B8%82%E8%A7%82%E5%AF%9F%E6%97%A5%E8%AE%B0181009%2F</url>
    <content type="text"><![CDATA[盘面分析 今天市场震荡分化，上证指数和上证50微红，其余指数小跌。从板块来看，采掘服务、石油、煤炭、次新股、航运、有色等板块涨幅居前，军工、国产软件、医药商业、半导体等板块跌幅居前。 截至收盘，沪指报2721.01点，涨幅0.17%；深成指报8046.39点，跌幅0.18%；创指报1345.95点，跌幅0.57%。创业板表现较差，盘中创出2014年8月以来新低。 创业板的走势并不容乐观，之后还可再等一等。中美贸易战对于国产软件股和芯片股都是利好，之后总有他们站出来的时候。 沪深300和上证50的反弹行情还可以继续关注，今天收出的小阳说明市场还是比较犹豫的，大家不知道是应该加仓还是之后会继续跌。大概在2700的位置会有一个支撑，如果这个位置没有撑住，那么建议观望一下。中线行情依旧是震荡磨底，可以高抛低吸降低成本。长线现在是不错的建仓时机，这从私募加仓也可以看得出来。 消息面 【私募开始加仓，主要布局大盘蓝筹、大消费及新经济板块】 相关数据显示，9月份私募平均仓位为62.5%，较8月份上升约10个百分点，逆转了前5个月平均仓位持续下滑的趋势。部分中小型私募在9月下旬开始左侧建仓，主要布局大盘蓝筹股、大消费及新经济板块，而部分大型私募也进行了“倒金字塔”式布局。某资深业内人士表示，“淡水泉、星石、重阳等知名私募，仓位一直维持较高，对市场长期走势维持乐观。值得关注的是，一些中小型私募在经历减仓后，9月份反而开始慢慢加仓。”（上证报） 【机构：9月CPI增速或上升 基建投资有望见底回升】 近日，多机构发布了对9月份宏观经济数据的预测。从发布的预测来看，市场对9月份及接下来的经济形势较为悲观，关注点主要集中于需求侧增长乏力及外贸风险方面。在CPI和PPI数据方面，多家机构认为9月份CPI同比增速将进一步抬升至2.5%左右，PPI同比增速进一步回落至3.7%左右。（证券时报）]]></content>
      <categories>
        <category>股市观察日记</category>
      </categories>
      <tags>
        <tag>Stock Analysis</tag>
        <tag>Technical Analysis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[国庆归来开门绿]]></title>
    <url>%2FJiamingXie.github.io%2F2018%2F10%2F08%2F%E8%82%A1%E5%B8%82%E8%A7%82%E5%AF%9F%E6%97%A5%E8%AE%B0181008%2F</url>
    <content type="text"><![CDATA[盘面分析 截至收盘，沪指收报2716.51点，跌3.72%，收创三个半月最大单日跌幅，成交额1415.3亿；深成指收报8060.83点，跌4.05%，成交额1474.1亿；创业板收报1353.67点，跌4.09%，成交额401亿。行业板块全线飘绿，个股一片普跌，跌停个股数早盘较少，但随着股指进一步下跌，午后两市跌停股数明显增多，市场恐慌情绪上升。安防、通讯、旅游酒店、保险、酿酒、电子、民航、软件等多个行业板块遭重挫，板块指数跌逾4%，医疗、环保、银行、文化传媒、航天航空、券商等行业板块跌幅也不浅，板块指数跌逾3%。公用事业、贵金属、石油等跌幅相对较小。 今天的这波暴跌其实还是比较符合预期的，只是当时没想到会杀这么多。国庆期间外围股市纷纷下跌，中国作为经济大国不可能独善其身，且民间有说法中国股市向来是跟跌不跟涨。国庆节期间可以说是有利空也有利好。利好是央行放水，降准，放了七个多亿出来，财政方面也有积极表示，这一步是为了帮助企业解决流动性问题，今年来因为还不上钱而使债券逾期的企业很多，也有很多投资公司因为钱收不回来不得不抛售手头其他的持仓股票。利空方面，贸易战全面打响；香港方面基本面数据并不好看；人民币补跌，破6.93，破8月15日来新低，收盘时收复至6.9。夜间美国方面开盘，依旧不改跌势，科技股普跌带领大盘。 目前看来不建议马上操作了，这一波持续了半个月的强力反弹在国庆的欢声笑语中结束了，现在依照外围的股市，A股还是比较有压力的，短期内很难马上反弹，但是这一波下杀同时也给了一个机会，会出现很多被大盘拖累的超跌股。目前A股的估值依旧处于历史低位，但是短期内可能比较难迅速有起色，毕竟去杠杆等政策对企业的流动性压力还是比较大的，经济基本面也并不是很好。长线依旧看好，现在是建仓机会。]]></content>
      <categories>
        <category>股市观察日记</category>
      </categories>
      <tags>
        <tag>Stock Analysis</tag>
        <tag>Technical Analysis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Control Statement Series]]></title>
    <url>%2FJiamingXie.github.io%2F2018%2F09%2F29%2FControl%20Statement%20Series%2F</url>
    <content type="text"><![CDATA[Operators (Advanced) in Java Compound assignment operators +=, -=, *=, /=, %= It is just the combination of operators and assignment operators. s = s+2 → s += 2 n1 = n1 * n2 → n1 *= n2 … Increment/decrement operators ++ and – If you want to increase by one or decrease by one, then you use “++” or “–” n += 1 → n++ n++ has assigned new value to n. 12345678int N1,N2;N1=9;System.out.printf("%d\n",N1++);//This statement will first print N1, and then add one to it. Thus, it will show the original value "9".System.out.printf("%d\n\n",N1); //Then in this line, 1 is added up to nine, so it will print 10N2=9;System.out.printf("%d\n",++N2);//before printf is executed, N2 will be added up to 1, so it will print 10System.out.printf("%d\n\n",N2);//This line will still print 10 The pre and post ++/– will make the result slightly different. 12345678int count, loop;count=9;loop=++count;//Then loop = 10, count=10count=9;loop= count++;//Then loop=9, count=10 Try the following program by yourself: 123456789101112int loop=8, count=15,Num;Num= +loop++;//The old value of loop is assigned to NumSystem.out.printf("Num=%d, loop=%d\n", Num, loop);//num=8,loop=9Num= ++Num;System.out.printf("Num=%d, loop=%d\n", Num, loop);//num=9, loop=9Num=count++ + loop;System.out.printf("Num=%d, loop=%d\n", Num, loop);//num=24=15(old count)+9 , count=16, loop = 9Num= --count+ --loop;System.out.printf("Num=%d, loop=%d\n", Num, loop);//num=15+8=23, count=15, loop = 8Num= loop + -Num;System.out.printf("Num=%d, loop=%d\n", Num, loop);//num= 8-23=-15 Operator precedence Plays role in mix of operators in a statement Precedence Rule applies for different operators Associative Rule applies for same operators Control Statements in JavaComputer algorithm can be described by using three types of control statement. Sequence: executed one by one; Selection: executed depending on conditionif12345678910//given an age, determine if the person is a teenagerint age;Scanner getInput = new Scanner(System.in);System.out.println("Enter your age:");age = getInput.nextInt();//teenager: age&gt;12 and age&lt;20if(age&gt;12 &amp;&amp; age&lt;20)&#123; System.out.println("You are a teenager.");&#125; if else1234567891011121314151617int age;Scanner getInput = new Scanner(System.in);System.out.println("Enter your score:");score = getInput.nextInt();//given a score score find out if the student go A,B,C,D, of F Grade//depending upon sliding scale of +90 A, 80-89 B, 70-79 C,60-69 D, &lt;59 Fif(score &gt;= 90) System.out.println("Your grade is A");else if(score &gt;= 80) System.out.println("Your grade is B");else if(score &gt;= 70) System.out.println("Your grade is C");else if(score &gt;= 60) System.out.println("Your grade is D");else System.out.println("Your grade is F"); switch1234567891011121314switch(ControllingExpression)&#123; case constant 1: statement; break; case constant 2: statement; break; case constant n: statement; break; default: statement;&#125; All “switch” statements can be converted to “if…else…” statements. Values for ‘case’: integer or character constants Cannot use expressions or ranges The order of the ‘case’ statements is unimportant The default clause may occur first 1234567891011121314151617181920212223242526272829303132float firstN;float secondN;char op;Scanner readInput = new Scanner(System.in);System.out.printf("Type a number, operator, number -- Separate by a space: ");firstN = readInput.nextInt();op = readInput.next().charAt(0);secondN = readInput.nextInt();if(op == '+') System.out.printf("%5.2f + %5.2f = %5.2f", firstN, secondN, firstN + secondN);else if(op == '-') System.out.printf("%5.2f - %5.2f = %5.2f", firstN, secondN, firstN - secondN);else if(op == '*') System.out.printf("%5.2f * %5.2f = %5.2f", firstN, secondN, firstN * secondN);else if(op == '/') System.out.printf("%5.2f / %5.2f = %5.2f", firstN, secondN, firstN / secondN);else if(op == '%') System.out.printf("%5.2f %% %5.2f = %d", firstN, secondN, (int)firstN % (int)secondN);else System.out.printf("Unknown operator");//convert the above code into case statementswitch(op)&#123; case '+': System.out.print("%5.2f + %5.2f = %5.2f", firstN, secondN, firstN + secondN);break;//"break" here is a must. If "break" is not used, then all the following command will be executed. case '-': System.out.print("%5.2f - %5.2f = %5.2f", firstN, secondN, firstN - secondN);break; case '*': System.out.print("%5.2f * %5.2f = %5.2f", firstN, secondN, firstN * secondN);break; case '/': System.out.print("%5.2f / %5.2f = %5.2f", firstN, secondN, firstN / secondN);break; case '%': System.out.print("%5.2f %% %5.2f = %d", firstN, secondN, (int)firstN %(int)secondN); break; default: System.out.printf("Unknown operator");&#125; 12345678910switch(age)&#123; case 13: case 14: case 15: case 16: case 17: case 18: case 19:System.out.println("You are a teenager.");break; default: System.out.println("You are not a teenager.");&#125; ?:Conditional operator: ? : Usually it is used for assignment. (expression1) ? expression2: expression3; If expression1 is true, expression2 will be evaluated, or expression3 will be evaluated. 1234567891011121314int max;System.out.printf("Type two numbers -- Separated by a space: ");firstN = readInput.nextInt();secondN = readInput.nextInt();if (firstN&gt;secondN) max=firstN;else max=secondN;System.out.println("The maximum of two numbers is: %5.2f",max);//convert to ?:max= (firstN&gt;secondN)? firstN: secondN; RepetitionLoop structure is used to repeat a block of statements Java provides two design of loop: controlled by an expression (counter) controlled by a sentinel value (trip, signal value) while loop123456789101112//Type1//repeat while evaluated control-expression is not 0statement1;while(control-expression)&#123; statement(s);&#125;statementn;//sampleint loop=0;while(loop++&lt;10) System.out.println("Hello World"); do while loop1234567891011121314151617181920//Type2//repeat while evaluated control-expression is not 0statement1(s);do&#123; statements;&#125;while;statement3(s);//sampleint loopCount=0;char charResponse="";Scanner readInput = new Scanner(System.in);do&#123; System.out.println("hello world"); System.out.println("Continue? Press n to stop:"); charResponse = readInput.next().charAt(0);&#125;while (charResponse!="n");//When the character entered is not "n", the loop will go on. Once you enter "n", the loop will stop.System.out.println("Done") For loop1234567//Type3//initialize expression1, repeat as expression2 is true and update expression3 each time.for(InitializeExpression; ControlExpression; UpdateExpression)&#123; BlockStatements;&#125; *Loops for a counter must contain three actions: Counter is initialized Counter is compared Counter is incremented 1234567891011int loop=0;while(loop&lt;10)&#123; loop++; System.out.println("%d", loop);&#125;//convert to for loopfor (int loop=0;loop&lt;10;loop++)&#123; System.out.println(loop);&#125; Use derement operator to count down use different counts Count by characters instead of numbers use any legal expressions for all three expressions Leave any expression blank Demo 123456789101112131415161718192021222324252627282930System.out.println("--------------------");System.out.println("| |");System.out.println("| |");System.out.println("| |");System.out.println("| |");System.out.println("| |");System.out.println("--------------------");//use while loop to draw first line of a box - 20 characters in width and uses "-"final int hSize=20;final int vSize=5;int count=0;while(count++&lt; hSize) System.out.print("-");System.out.printf("/n");int count2=0;while(count2++&lt; vSize-2)&#123; System.out.print("|"); count=0; while(count++&lt; hSize-2) System.out.print(" "); System.out.print("|"); System.out.printf("/n");&#125;count=0;while(count++&lt; hSize) System.out.print("-");System.out.printf("/n");]]></content>
      <categories>
        <category>Java for Dummies</category>
      </categories>
      <tags>
        <tag>coding</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[强者恒强]]></title>
    <url>%2FJiamingXie.github.io%2F2018%2F09%2F28%2F%E8%82%A1%E5%B8%82%E8%A7%82%E5%AF%9F%E6%97%A5%E8%AE%B0180928%2F</url>
    <content type="text"><![CDATA[盘面分析 沪指收报2821.35点，涨1.06%，成交额1254亿。深成指收报8401.09点，涨0.80%，成交额1378亿。创业板收报1411.34点，涨0.78%，成交额414亿。沪指全周上涨0.85%，深成指跌0.10%，创业板指涨0.02%。沪指本月上涨3.53%，创1月份来最大单月涨幅；深成指跌0.76%，创业板指跌1.66%。 28日，节前最后一个交易日，两市小幅高开，在北汽新能源板块的带动下，市场一度冲高，但此后大盘随即回落，次新股较昨日显著回暖，市场逐渐企稳，银行、保险逐渐活跃，指数稳步上行，午后两市稳步走强，有色板块的拉升刺激了主板指数的上行，而以银之杰为首的创业板人气股则带动了一波中小创，市场整体较昨日明显活跃，盘面上看，大盘个股涨多跌少，市场上呈现权重搭台，题材唱戏的走势，临近尾盘，指数高位盘整。 经过这两周的上涨，大盘可能会进入横盘整理的阶段，震荡期间可以高抛低吸，或者借机入场。 消息面 李克强：民营经济的管理者、经营者和生产者，都是中国特色社会主义的建设者 李克强总理9月28日上午在浙江台州主持召开座谈会。李克强说，民营经济和国有经济一样，都是社会主义市场经济的重要组成部分。民营经济的管理者、经营者和生产者，都是中国特色社会主义的建设者。我国的基本经济制度以及社会主义市场经济早已写入宪法。必须坚持“两个毫不动摇”，对各类所有制企业一视同仁，这一点绝不会有任何变化。 李克强：下一步要更大力度简政、减税、减费 李克强28日上午在浙江台州主持召开座谈会。听取企业家关于实体经济发展的意见建议后，李克强明确表示，下一步要更大力度简政、减税、减费。“简政”要继续深化“放管服”改革，降低制度性交易成本。“减税”要加快推进增值税税率“三档变两档”，研究降低增值税税率。“减费”要动真格地降低合规收费，坚决惩治乱收费，同时继续降低企业物流、电力等各类成本。 深交所三季报预披露时间表出炉，原来首家披露的公司益生股份已更改。现为炼石有色拔得头筹，将于10月9日披露。原定于10月10日披露的益生股份，现改为10月16日披露。]]></content>
      <categories>
        <category>股市观察日记</category>
      </categories>
      <tags>
        <tag>Stock Analysis</tag>
        <tag>Technical Analysis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[节前小调]]></title>
    <url>%2FJiamingXie.github.io%2F2018%2F09%2F27%2F%E8%82%A1%E5%B8%82%E8%A7%82%E5%AF%9F%E6%97%A5%E8%AE%B0180927%2F</url>
    <content type="text"><![CDATA[盘面分析 截至收盘，沪指收报2791.77点，跌0.54%，成交额1234亿。深成指收报8334.75点，跌1.02%，成交额1626亿。创业板收报1400.36点，跌1.44%，成交额495亿。三大指数小幅低开，昨日活跃的权重股集体回调，而中小创也表现颓势，节前倒数第二个交易日，市场抛压较大，此后医药股拉升，带动指数一度走强，但两市依旧冲高回落，午后指数稳步走弱，有色钒板块的冲高一度带动有色金属板块的走强，但大盘依旧颓势，期指单边下行毫无反抗，临近尾盘，大盘持续走低。 早盘的时候的上突有点“作死”的意味，这种时候如果能下跌把空方力量释放干净反而是比较健康的。中午我们预测在2790点位会反弹，事实是反弹了，但是这一下太猛了，作死第二突彻底把今天的走势给突死了。本来的预期是砸下去拉上来收一个下影线，现在看来市场比我们预期要弱。 预计节前最后一个交易日还是以回调为主，节后调整过后还会有一波行情，但是具体的情况需要看国庆节外盘的情况和消息面来推断，接下来的震荡期间还是有入场机会。 消息面 富时罗素CEO：五到十年内会有2.5万亿美元增量资金流入中国证券市场 富时罗素CEO麦思平说：“全球大概有25万亿美元的被动资金追踪富时罗素和MSCI两大指数公司。我们相信中国市场规模在未来能够占25万亿美元的10%以上，也就是大约2.5万亿美元的被动资金将有望在未来五到十年内流入A股市场。”（上证报） 习近平：党中央毫不动摇地支持民营经济发展 27日上午，习近平在辽宁忠旺集团考察。习近平强调，改革开放以来，党中央始终关心支持爱护民营企业。我们毫不动摇地发展公有制经济，毫不动摇地鼓励、支持、引导、保护民营经济发展。现在的很多改革举措都是围绕怎么进一步发展民营经济，对这一点民营企业要进一步增强信心。我们要为民营企业营造好的法治环境，进一步优化营商环境。党的路线方针政策是有益于、有利于民营企业发展的。民营企业也要进一步弘扬企业家精神、工匠精神，抓住主业，心无旁骛，力争做出更多的一流产品，发展一流的产业，为实现“两个一百年”目标作出新的贡献。（新华社） 习近平：怀疑、唱衰国企的思想和言论都是错误的 27日上午，习近平来到中国石油辽阳石化公司考察。他强调，我们的国有企业要继续做强做优做大，那种不要国有企业、搞小国有企业的说法、论调都是错误的、片面的。我们实行公有制为主体、多种所有制经济共同发展的基本经济制度，这一点毫不动摇。任何怀疑、唱衰国有企业的思想和言论都是错误的。坚持党对国有企业的领导，必须一以贯之；国有企业建立现代企业制度，也必须一以贯之。我们要沿着这条路笃定踏实地向前推进。（新华社） 减税万亿红利将深度释放 新一轮减税举措细则将密集落地 我国新个税红利释放在即，10月1日起，我国个税起征点将实现从3500元调至5000元，与此同时，3％、10％和20%三档税率级距也将扩大。业内指出，调高起征点和调整税率将释放减税效应，尤其是月薪两万以下收入群体的减税效应更加明显。不仅仅是个税，事实上，近期伴随新一轮减税举措细则的密集落地，我国减税政策掷地有声，全年万亿红利将深度释放。（经参） 特别鸣谢]]></content>
      <categories>
        <category>股市观察日记</category>
      </categories>
      <tags>
        <tag>Stock Analysis</tag>
        <tag>Technical Analysis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Natural Language Processing - 使用sklearn进行文本特征提取]]></title>
    <url>%2FJiamingXie.github.io%2F2018%2F09%2F27%2FNatural%20Language%20Processing%20-%20Feature%20Extraction%20and%20Selection%2F</url>
    <content type="text"><![CDATA[分词 Word Segmentationjieba中文分词是一款完全开源的分词工具，是现在最主流的分词包之一。 分词阶段的预处理工作主要有两个，一个是分词，一个是去掉停词（stop words）。 stop_words是一个由停词组成的列表。 1234stpwrdpath=' .txt'with open(stpwrdpath, 'rb') as fp: stopword= fp.read().decode('utf-8') #extract stop wordsstpwrdlst =stopword.splitlines() 1234567891011121314151617import jiebadef words_segment(input_string, stop_words=[]): ''' The function use jieba to segment sentences and remove characters/words in stop_words. Input: input_string: string, the sentence to segment. stop_words: list of strings that are going to be removed after word segmentation. Output: word_result = string, words joined by blank space after segmentation. ''' seg_generator=jieba.cut(input_string, cut_all= False) word_result= " " for word in seg_generator: if word not in stop_words_list: word_result += (word + ' ') return word_result 文本转化为代表词频的特征向量 CountVectorize12345678910from sklearn.feature_extraction.text import CountVectorizervectorizer = CountVectorizer(stop_words=stpwrdlst)context_vector = vectorizer.fit_transform(listOfStirng) #Learn the vocabulary dictionary and return term-document matrix.#listOfString: The list containing all the sentences.print(vectorizer.get_feature_names()) #get the list of feature wordsprint(vectorizer.vocabulary_) #get the dictionary of feature words and # of occuranceprint(vectorizer.toarray()) #get the sparse=matrix of feature occurancefor key,value in vectorizer.vocabulary_.items(): print(key,value) #print feature words and # of occurance one by one token_pattern的使用 因为有些时候CountVectorizer会把一个专有名词也按照空格分开，有时并不符合需求。比如：World Economic Forum 可以通过token_pattern来自定义分隔符 1234567891011nn=[ "People's Republic of China@中华人民共和国。", "World Economic Forum@世界经济论坛" ]from sklearn.feature_extraction.text import CountVectorizer#默认token_pattern=r"(?u)\b\w\w+\b"vectorizer=CountVectorizer(token_pattern=r"(?u)\b[^@]+\b")wordFrequencyMatrix = vectorizer.fit_transform(nn)for f in vectorizer.get_feature_names(): print (f) 逆文档频率 TfidfVectorizer/TfidfTransformerTerm Frequency (TF): $$tf(t,d)=\frac{f(t,d)+1}{||x||}$$ $f(t,d)$: frequency of term t in document d ||x||: (Euclidean distance) L2 norm of the count vector. Inverse Document Frequency (IDF): measures how rare or common a word is in a corpus. $$idf(t,d)=log\frac{N}{1+|d\ \in\ D :\ t\ \in\ d|}$$ N: Total # of documents in the corpus $d\ \in\ D :\ t\ \in\ d$ is the # of ducuments in the corpus that contain the term t. Words like “I”, “will” contribute little to the classification of texts. Thus, idf will penalize the importance of this kind of words. 如果一类文本（比如说讲篮球赛的文本中过分频繁出现一些词如“篮球”“篮板”等词语）频繁出现一些对文本分类没有贡献的词，那么这类词的重要性会被IDF“惩罚”（penalized）。 在分词以后就可以将文本转化为逆文档词频的特征向量（矩阵） 1234567891011121314151617181920212223from sklearn.feature_extraction.text import CountVectorizerfrom sklearn.feature_extraction.text import TfidfTransformerlistOfStirng=["","","",""]vectorizer = CountVectorizer(stop_words=stpwrdlst)context_vector = vectorizer.fit_transform(listOfStirng)tfidf_transformer=TfidfTransformer()tfidf=tfidf_transformer.fit_transform(context_vector)#calculate tf-idf for each word featureword=vectorizer.get_feature_names() #name of different featuresweight=tfidf.toarray() #the matrix of feature weight of different key wordsfor i in range(len(weight)):#print the keyword and feature weight in each text for j in range(len(word)): print(word[j], weight[i][j]) #######################################################from sklearn.feature_extraction.text import TfidfVectorizerlistOfStirng=["","","",""]tfidf=TfidfVectorizer(stop_words=stopwordlist)weight=tfidf.fit_transform(all_list).toarray()#the matrix of feature weight of different key wordsword=tfidf.get_feature_names()#name of different featuresfor i in range(len(weight)):#print the keyword and feature weight in each text for j in range(len(word)): print(word[j], weight[i][j]) Thus, CountVectorizer + TfidfTransformer = TfidVectorizer. 特征选择 Feature SelectionUnivariate feature selection SelectKBest: removes all but the k highest scoring features SelectPercentile: emoves all but a user-specified highest scoring percentage of features Chi-squared: chi2(X,y) computes chi-squared stats between each non-negative feature and class. 1234567891011&gt;&gt;&gt; from sklearn.datasets import load_iris&gt;&gt;&gt; from sklearn.feature_selection import SelectKBest&gt;&gt;&gt; from sklearn.feature_selection import chi2&gt;&gt;&gt; iris = load_iris()&gt;&gt;&gt; X, y = iris.data, iris.target&gt;&gt;&gt; X.shape(150, 4)&gt;&gt;&gt; X_new = SelectKBest(chi2, k=2).fit_transform(X, y)#choose the best two features&gt;&gt;&gt; X_new.shape(150, 2) Chi2 can be changed to other objects: regression: f_regression classification: chi2/f_classif]]></content>
      <categories>
        <category>Data Mining</category>
      </categories>
      <tags>
        <tag>NLP</tag>
        <tag>Machine Learning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[重磅利好？MSCI拟将提高A股纳入因子]]></title>
    <url>%2FJiamingXie.github.io%2F2018%2F09%2F26%2F%E8%82%A1%E5%B8%82%E8%A7%82%E5%AF%9F%E6%97%A5%E8%AE%B0180926%2F</url>
    <content type="text"><![CDATA[盘面分析 截至收盘，沪指收报2806.81点，涨0.92%，成交额1451亿。深成指收报8420.54点，涨0.80%，成交额1653亿。创业板收报1420.75点，涨1.06%，成交额466亿。早盘三大指数小幅高开，随后白马股表现强势，白酒、保险板块持续走强，但是中小创则依然萎靡，午后指数冲高回落，盘面上物流板块持续活跃，两市个股普涨，板块多数飘红，临近尾盘，大盘持续震荡。 从技术面上来看，今天的整体走势还是相当强劲的，比预期中要更强一些，但是还是冲高回落拉出了一根上影线。今天的这波涨势很可能是得益于MSCI考虑提高A股权重以及富时罗素考虑将A股纳入其指数体系。股票市场提前反应了这个预期。俗话说：“利好出尽是利空”。不管是不是纳入指数体系，预计明天都会有一定幅度的回调。纳入了就是小跌，没有纳入就是大跌。 节前两天的走势估计是小幅度回调加横盘震荡，节后继续震荡上行。 消息面 MSCI考虑将中国大盘A股纳入因子提高3倍 北京时间9月26日，国际大型指数公司MSCI发布新闻稿称，就进一步提高A股在MSCI指数中的权重展开咨询，MSCI表示，此次咨询是在建立在中国A股以5％的纳入因子首次加入MSCI中国指数及其相关综合性指数（如MSCI新兴市场指数）的成功实施基础上。 为此，MSCI进一步提出三项建议： 将中国大盘A股的纳入因子从5％增加到20％，于2019年5月半年度指数评审和2019年8月季度指数评审这两个阶级分步实施; 从2019年5月半年度指数评审开始，将深交所创业板市场加入符合MSCI指数条件的证券交易所名单; 作为2020年5月半年度指数评审的一部分，将中国中盘A股以20%的纳入因子一步纳入MSCI中国指数。 【MSCI：660亿美元增量资金将入市】MSCI亚太研究部主管谢征傧告诉记者，根据MSCI测算，以每5%的因子纳入A股，带来的资金大约是220亿。若此次咨询结果正面，则A股纳入的因子提升至4倍，基于5%的纳入因子带来的资金量测算，预计将有660亿美元的海外增量资金。（中国证券网） 同时，富时罗素将在北京时间9月27日凌晨正式宣布是否将中国A股纳入其指数体系，坊间普遍认为，从目前情势来看，A股被纳入的概率极大。 特别鸣谢]]></content>
      <categories>
        <category>股市观察日记</category>
      </categories>
      <tags>
        <tag>Stock Analysis</tag>
        <tag>Technical Analysis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Operators - Assignment, Arithmetic, Relational, Logical]]></title>
    <url>%2FJiamingXie.github.io%2F2018%2F09%2F26%2FOperators%20-%20Assignment%2C%20Arithmetic%2C%20Relational%2C%20Logical%2F</url>
    <content type="text"><![CDATA[Assignment Operator Assigns the value from right operand to the left. ‘=’ operator is used as assignment operator Variable = Expression A = B; yourSalary= GetYourSalary(); int temp = 55; Arithmetic OperatorUnary: require only one operand +, - ++ Pre/Post Increment – Pre/Post Decrement % Modulus/Remainder: e.g. 99%2=1 Binary: require two operands Control StatementExecute different code depending upon circumstances. “if” is one of the control statements. There is also another one control statement-“if…else”, “if…else if….else” 123456789101112131415161718import java.util.Scanner;public class FirstJavaClass&#123; public static void main(String[] args) &#123; int yourAge; //implicit initializing int myAge = 21; //explicit initializing Scanner readInput= new Scanner(System.in); System.out.printf("How old are you?"); yourAge=readInput.nextInt();// Assign the value of next input to readInput. if (yourAge &gt; 50)&#123; System.out.printf("You are golden.\n"); &#125;//Even if it is just one line, you'd better add "&#123;&#125;" here. else&#123; System.out.printf("You are not so golden.\n"); &#125; &#125;&#125; Relational OperatorIt defines the relation between operands. Operator Meaning == Equal != Not equal &lt; less than &gt; more than &lt;= Less than or equal to &gt;= More than or equal to Every relational expression evaluates to a True or a False. Logical Operatorsused for multiple conditions in a statement. Operator Meaning &amp;&amp; AND &#124;&#124; OR ! NOT DemoDemo 1 It is just the same as the previous one, but let me mention a little bit about this “args” in the last line. “args”, which comes from main, is a command line argument. Suppose you run the program from the command. You need to run the folloing code: 1java Helloworld 50 60 You need to passing some value to it. This 50 and 60 will come into the argument. 123456789101112131415161718192021import java.util.Scanner;public class FirstJavaClass&#123; //command line // public static void main(String[] args) &#123; int yourAge; //implicit initializing int myAge = 21; //explicit initializing Scanner readInput= new Scanner(System.in); System.out.printf("How old are you?"); yourAge=readInput.nextInt();// Assign the value of next input to readInput. if (yourAge &gt; 50)&#123; System.out.printf("You are golden.\n"); &#125;//Even if it is just one line, you'd better add "&#123;&#125;" here. else&#123; System.out.printf("You are not so golden.\n"); &#125; System.out.printf("I told you so",args[1]) &#125;&#125; This args will contain 50 and 60. args[0]=50, args[1]=60. Demo 2 Write a program which asks the user to enter their age and then you print the following messages, depending upon their age: If the age is less than 13, then say ‘you are a kid’; if the age is greater than 19, then say ‘you are an adult’; otherwise say ‘you are a teenager’. 1234567891011121314151617181920212223import java.util.Scanner;public class AgeCheck&#123; public static void main(String[] args) &#123; int yourAge; Scanner readInput= new Scanner(System.in); System.out.printf("Please enter your age:"); yourAge=readInput.nextInt(); //if (yourAge&gt;12 &amp;&amp; yourAge&lt;20) //System.out.printf("You are a teenager."); if (yourAge &lt;= 13)&#123; System.out.printf("You are a kid.\n"); &#125; else if (yourAge &gt; 19)&#123; System.out.printf("You are an adult.\n"); &#125; else&#123; System.out.printf("You are a teenager."); &#125; &#125;&#125;]]></content>
      <categories>
        <category>Java for Dummies</category>
      </categories>
      <tags>
        <tag>coding</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Data Types - Primitive Data Types, Usage]]></title>
    <url>%2FJiamingXie.github.io%2F2018%2F09%2F26%2FData%20Types%20-%20Primitive%20Data%20Types%2C%20Usage%2F</url>
    <content type="text"><![CDATA[Statements: TokensTokens are the smallest element parsed by the compiler. KeywordsThe reserved words of java language, like 12345678910voidpublicclassfinal.whiledoforifelse You use this words for special purposes. Names (Identifiers)Names are used to identify your program elements. The variable and method names, like radius, pi, println, area, main… 123456789101112public class FirstClass&#123; public static void main(String[] args) &#123; int radius=2; double area; final double pi=3.142; area=pi*radius*radius; System.out.print("The area is: "); System.out.println(area); &#125;&#125; Naming rules and conventions Rules: Any length Must be within a letter May contain digits and underscores Case sensitive Convention: (Not mandatory) Generally variables are lower case characters and numbers Avoid using underscores. Capitalize the first letter of second word if needed: myHeight PunctuationCharacter constantsOne character ‘A’, ‘a’, ‘9’, ‘$’, ‘%’ One character defined character set Must surround by single quotation mark There should be only one character. ‘ab’, ‘abc’ are wrong. String constantsNumeric constantsContiguous sequence of digits Never contains a dollar, comma or space May contain a decimal (dot) e.g. 1023, 5.5 OperatorsAct upon operands Assignment Operators: = Arithmetic Operators: +,-,*,/,% Relational Operators: &lt;, &lt;=, ==, &gt;=, &gt; != White space, Special Symbol1; : , '' [] &#123;&#125; () = ... # Data Types Memory It is like rows of post box (slot) to store data Number of slot is its address where one byte of data can be stored Some logical data value can spam more than one slot When you define a variable, the computer creates a place for it. Data Type Type names a logical meaning to a span of memory You should be able to answer “What is data type?” during an interview. e.g. Int, float etc. Byte: for small numbers and characters (-127 to 128) \Characters are also stored as number. So you can mix number and characters with Byte.* Hence it can alse be printed in number. It is only the matter that how you want to display it. 123456789byte myChar='A';byte myNumber= 65;String myString= "Hello How are you";//You can assign different data type when print the input.System.out.printf("The value is: %c \n", myChar);System.out.printf("The myChar in number is: %d \n", myChar);//Since myChar is a byte, it is stored in number and can be printed in number.System.out.printf("The value is: %d \n", myNumber);System.out.printf("%s\n", myString); Character: To support Unicode Integer: Regular, short and long 1numberOfStars = 10000000000000L; // an L is need at the end Real numbers: Floating and Double Boolean: True or False Variable a place in memory to store a value of certain type that has a name Define a variable: Name and type Optionally can initialize e.g. radius, area, pi 123//data_type variable_name;int value1;int value2, sum; Initializing Variables Declarations create variables, but do not provide a value 123//variable_name=expressionvalue1 = 324;int value2=6; Demo123456789101112131415161718192021222324import java.util.Scanner;public class FirstClass&#123; public static void main(String[] args) &#123; int radius; double area; final double pi=3.142; Scanner readInput = new Scanner(System.in); System.out.print("Enter the radius:"); radius = readInput.nextInt(); area=pi*radius*radius; System.out.print("The area of radius" + radius + "is: " + area); System.out.printf("The area of radius %d is: %5.2f \nI am done.", radius, area); System.out.printf("The percentage of radius to area in %% is %f", pi); //If you want to print a "%", you need to add another "%" before it. &#125;&#125; 123456789101112131415161718192021import java.util.Scanner;public class FirstClass&#123; public static void main(String[] args) &#123; short numberOfStudents=11; int presidentsSalary=400000; long numberOfStars=100000; //initialization Scanner readInput= new Scanner(System.in); System.out.printf("Number of stars in our University: %d \n\n", numberOfStars); numberOfStars=1000000000000L; //reassign the variable //without L there is error System.out.printf("Number of stars in our Milkway: %d \n\n", numberOfStars); //reassign the variable System.out.printf("Please enter number of students and presidents salary: \n"); //you just need to add a space between two inputs numberOfStudents=readInput.nextShort(); presidentsSalary=readInput.nextInt(); System.out.printf("Number of students:" + numberOfStudents); System.out.printf("President's Salary + Bonus" + presidentsSalary*1.25); &#125;&#125;]]></content>
      <categories>
        <category>Java for Dummies</category>
      </categories>
      <tags>
        <tag>coding</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[股市观察日记180925]]></title>
    <url>%2FJiamingXie.github.io%2F2018%2F09%2F25%2F%E8%82%A1%E5%B8%82%E8%A7%82%E5%AF%9F%E6%97%A5%E8%AE%B0180925%2F</url>
    <content type="text"><![CDATA[盘面分析 截止收盘，沪指报2781.14点，跌0.58%，深成指报8353.38点，跌0.66%；创指报1405.81点，跌0.38%。从盘面上看，农服、物流、赛马等板块涨幅居前，机场航运、房地产开发、银行等板块跌幅居前。从技术面上看是比较正常的回调。 今日上涨的股票多为周末有利好的板块：军工、农业、国产软件、电子元件等；油服板块上涨受益于周末原油期货大涨。 后续估计下跌空间不大，但是会回踩2750位置，震荡回调或是入场时机。 消息面 房地产行业大地震 有媒体报道，监管部门向多省下发函件，要求住建厅对商品房预售许可进行深入研究论证；有传言称广东要取消房地产预售制度。 取消预售制度无疑是“去杠杆”中的一环，此政策将会降低了房企的流动性，从而导致利润下降。 所以昨天外盘中资地产集体暴跌：融信中国下跌10.71%，绿城中国下跌6.22%，碧桂园、华润置地、融创中国下跌超过4%，内资房地产股一天蒸发市值超过600亿港元。今天A股地产也领跌，早盘保利地产、万科A、招商蛇口、新城控股等跌幅超3%。 接下来大的趋势是维稳，稳定房价，所以房价很难会再有像之前一样疯狂的上涨。虽然地产股现在处于估值低位而且业绩不错，之后的投资价值还有待考证。 （吃瓜）刘强东性侵案或有新进展 媒体又爆出了刘强东性侵案的新细节，包括女生的微信求助内容，里面声称被灌醉，并想自杀，且保留了床单。目前检方正在决定是否起诉。 受此消息影响，京东再次暴跌近8%，收24.51。 京东今年以来的股价走势十分疲弱，自今年1月创下50.68美元纪录最高价以来，京东股价跌幅超过50%。京东股价在涉嫌性侵犯事件曝光后（9月之后），跌幅超过20%，市值蒸发约88亿美元(对应约602亿人民币)。 拼多多昨收26.49，与京东的市值差距进一步缩小。 外资加快布局A股市场 去年前10个月，仅有富达中国债券一号私募基金一只基金发行。去年11月到今年9月，外资私募发行已达18只。 据中国基金报统计，截至9月25日，已有贝莱德、富达、瑞银、富敦、英仕曼、惠理、景顺纵横、路博迈、安本、施罗德、安中、元胜、桥水、毕盛等14家外资机构先后获得私募证券投资基金管理人资格，除桥水、毕盛尚未发行产品外，其余12家发行的外资私募基金产品数量达19只产品。 今年6 月 A 股正式纳入 MSCI 新兴市场指数，9 月27日又可能纳入富时罗素国际指数体系，将进一步对外资投资A股形成吸引力。 且现在A股估值处于历史低点，或是布局的好时机。]]></content>
      <categories>
        <category>股市观察日记</category>
      </categories>
      <tags>
        <tag>Stock Analysis</tag>
        <tag>Technical Analysis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Input/Output - Input From User, Formatted Output to the User]]></title>
    <url>%2FJiamingXie.github.io%2F2018%2F09%2F25%2FInput%3AOutput%20-%20Input%20From%20User%2C%20Formatted%20Output%20to%20the%20User%2F</url>
    <content type="text"><![CDATA[Comments in Java First lines are comments, ignored by compiler. Needed for maintenance purposes. Use // for single line, / / for multiline. Over commenting is not good. Must maintain comments as well. 12345//PROGRAM: FirstJavaHello.java/*Known Issues:Revise:*/ Dissecting the program (Java Class) Every code in Java is inside a class. It has a body with {}. The name of the class becomes the name of the application. The file name must be the name of class. javac compiles the .java file and produces .class byte code. 123456789public class HelloWorld&#123; /** * @param args */ public static void main(String[] args) &#123; //TODO Auto-generated method stub System.out.println("Hello World!"); &#125;&#125; Dissecting the program(method main) Java program starts executing with a method called main(). It has a body within {}. It is unique. System.out is an object which knows how to display a character in a terminal. println is the message sent to the System.out object. Demo123456789101112public class FirstClass&#123; public static void main(String[] args) &#123; int radius=2; // create a constant called radius double area; final double pi=3.142; //"final" means pi is a constant. area=pi*radius*radius; System.out.print("The area is: ");// The cursor will not go to the next line System.out.println(area);// The cursor will go to the next line &#125;&#125; We will not change the constant after the programming is done, so we may need an place for input. 1234567891011121314151617181920212223242526import java.util.Scanner;public class FirstClass&#123; public static void main(String[] args) &#123; //Primitive datatype int radius; // a variable, can hold different value when run double area; final double pi=3.142; //object Scanner readInput = new Scanner(System.in); //readInput is any name you want to give to it. //Scanner is not a java datatype. It is a user defined datatype. So if you want to use it, you need to add "new" //System.in is used to reformat what the user inputs through keyborad. //It is called reference in this case. System.out.print("Enter the radius:"); radius = readInput.nextInt();//use the reference and send message //by calling a method nextInt(): "give me the next //integer you have" area=pi*radius*radius; System.out.print("The area is: "); System.out.print(area); &#125;&#125; Input/Output in JavaInput Operation Copy data from input device Performed by usin methods in library like Scanner package Format specifier specifics to the data type is used. e.g. %d for integer, %f for float ##Output Operation Display information stored in memory to output device usually a screen. Performed by output methods in System.out package. Format specifier specifics to the data type is used. Use Scanner, System.out packages print, printf, println methods Display information in std output device Syntax: print(FormatControlString); print(FormatControlString,datalist); FormatControlString: Contains characters, format specifier, and escape sequences Datalist: Contains any constants, variables, expressions, and function calls separated by commas 1234567byte myChar='A';byte myNumber= 65;String myString= "Hello How are you";System.out.printf("The value is: %c", myChar);System.out.printf("The value is: %d", myNumber);System.out.printf("%s\n", myString); Escape sequence Special meaning if used in printf() method Causes escape from normal interpretation of format specifier string “\r” moves cursor to the beginning of the current line and overwrite the previous characters. (Only in a DOS window you can see the effect.) Demo 1234567891011121314151617public class FirstClass&#123; public static void main(String[] args) &#123; System.out.printf("Java is fun."); System.out.printf("\rHello Student"); System.out.printf("\nHello World\n"); //adding "\n" at the beginning-start from the next line System.out.printf("\n"); System.out.printf("First Name \tLast Name\tCity\n"); //"\t" means tab System.out.printf("-----------\t----------\t---\n"); System.out.printf("Bill \tClinton \tHarlem\n"); System.out.printf("\n\n"); System.out.printf("Who said \"Test Scores Can Be Used ....\"\n"); &#125;&#125;]]></content>
      <categories>
        <category>Java for Dummies</category>
      </categories>
      <tags>
        <tag>coding</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[股市观察日记180828]]></title>
    <url>%2FJiamingXie.github.io%2F2018%2F08%2F28%2F%E8%82%A1%E5%B8%82%E8%A7%82%E5%AF%9F%E6%97%A5%E8%AE%B0180828%2F</url>
    <content type="text"><![CDATA[今天是实习的最后一天了…… 一般1点40分左右的上突，都没什么好事儿。 相当于强上，然后就被套了，接下来的走势比较不乐观。 没有热点板块带动，上涨无力. 接下来这一波，本来应该期待的是拉一根阳线补上缺口，现在看照日内走势并不是非常乐观，可能要再缓一缓。 看一下中线的分析： 1号阴线本来是算是一个回踩但是后面又创了一个新低，说明1号阴线踩下的不是底部，2号到4号的底部比上1和3的差值已经缩小了，量能上看也大幅度缩小。 接下来是两根中阳线，如果本周能够收复3号阳线的失地，那么这根阴线就算消化完了，否则不乐观。 估计之后的走势会先上突补上缺口，补上缺口以后马上下来踩稳，不要低过阴线的开盘价，那么算回踩成功。 如果补上缺口还硬向上突，量能又不够，那么久很容易哐叽，下来更惨，可能支撑位都踩不住。 今天的大盘走势很有趣，下午1点40分上突的时候，预计接下来的走势不太乐观。 但是后面下跌到0.35%左右就止跌了，这个时候走势开始分化。这个时候要分析是谁往上走了，是谁往下走了。 宏观分析一下，这两天的涨势是谁带起来的，金融、止跌的白马、科技股。这几个板块这几天轮流上涨，现在有点乏力了。 让我们来看一下老大哥 之前在大盘还在跌的时候就开始上攻，让大盘有三天上涨的行情，之后开始横盘，这几天股市涨得比较多，但是铁建也没涨多少。 下午的时候需要有股站出来，这只股就是基建股。因为基建股差不多休息好了。 预计明天早上会上冲破一个前高到11块，靠惯性再上突一下然后收个小阳线。（其他个股和大盘明天还会下跌。） 如何看出老大哥要出马了？ 大盘下跌的时候，铁建反其道而行之向上突了一下，再结合之前的日级别走向和基建龙头的身份，这一上突就是在指明它就是铁建的大哥，后续果然强势上涨。]]></content>
      <categories>
        <category>股市观察日记</category>
      </categories>
      <tags>
        <tag>Stock Analysis</tag>
        <tag>Technical Analysis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[股市观察日记180823]]></title>
    <url>%2FJiamingXie.github.io%2F2018%2F08%2F23%2F%E8%82%A1%E5%B8%82%E8%A7%82%E5%AF%9F%E6%97%A5%E8%AE%B0180823%2F</url>
    <content type="text"><![CDATA[市场情绪低迷，交易量持续萎缩。（昨天创下熔断后最少交易量） 天量见天价，地量见地价。这个底不知道是不是真的底，但是貌似主力是认可中长线底部的。 由于交易量过小，下午这种急速拉升是非常容易的。稍微有一点儿资金就会涨，但是不容易跌，因为深度套牢的股民很多，没有人卖。]]></content>
      <categories>
        <category>股市观察日记</category>
      </categories>
      <tags>
        <tag>Stock Analysis</tag>
        <tag>Technical Analysis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[股市观察日记180816]]></title>
    <url>%2FJiamingXie.github.io%2F2018%2F08%2F16%2F%E8%82%A1%E5%B8%82%E8%A7%82%E5%AF%9F%E6%97%A5%E8%AE%B0180816%2F</url>
    <content type="text"><![CDATA[昨天指数跌得厉害但是交易量非常小，看得出是权重股带头砸指数。 一般这种情况下第二天都是低开走势。这与之前有几天的走势是非常相似的。 这个时候注意不可以再进货，反弹的时候反而是出货的机会。因为之后几天还会有跌势。 今天的低开是意料之中，但是没有想到低开这么多，接下来就是看2691这个点位能否撑住，若撑不住之后的走势则不乐观。 早上回踩1691的地方是确认，做空期货的空方需在此平仓，因为将迎来反弹。]]></content>
      <categories>
        <category>股市观察日记</category>
      </categories>
      <tags>
        <tag>Stock Analysis</tag>
        <tag>Technical Analysis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[股市观察日记180814]]></title>
    <url>%2FJiamingXie.github.io%2F2018%2F08%2F14%2F%E8%82%A1%E5%B8%82%E8%A7%82%E5%AF%9F%E6%97%A5%E8%AE%B0180814%2F</url>
    <content type="text"><![CDATA[今天大盘的走势算是比较不健康的。 早盘上突两次（而且非常急，图线非常陡峭），后面就开始一轮急跌。 下午一直横盘，横盘时间过长，需要选择方向。两点钟之前上突一次，让下跌更容易。 大概2点多的时候上突两次，看第三次动作，上突成功，说明基本企稳。 不过由于之前上突了一次，之后可能还会有反复。 本周接下来的行情很有可能会反复踩稳这个短期底部。 今天“作”出来的这几下上突还有待消化。]]></content>
      <categories>
        <category>股市观察日记</category>
      </categories>
      <tags>
        <tag>Stock Analysis</tag>
        <tag>Technical Analysis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[股市观察日记180810]]></title>
    <url>%2FJiamingXie.github.io%2F2018%2F08%2F10%2F%E8%82%A1%E5%B8%82%E8%A7%82%E5%AF%9F%E6%97%A5%E8%AE%B0180810%2F</url>
    <content type="text"><![CDATA[大盘 看IF的线，第一下上冲，第二下上冲的尖儿太明显了，第三下说明上冲的意愿还是挺明显的，下跌空间不会太大。 如果下去可以一跌到位，那么之后的形式会比较乐观。 如果不到位的话走势反而不健康。 三次上突失败，接下来就是下行两次，震荡踩实。 炒股只炒龙头股的原因 带动板块上升，个股不涨了它还会涨；带动板块回调，个股不跌了它还会继续跌。上下的浮动也随之增大。 看下图，板块涨的时候它不涨，后板块突第二下的时候意思了一下，但是DDX已经向下了，一直在出，接下来就看什么时候开始带头砸盘了。]]></content>
      <categories>
        <category>股市观察日记</category>
      </categories>
      <tags>
        <tag>Stock Analysis</tag>
        <tag>Technical Analysis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[股市观察日记180806]]></title>
    <url>%2FJiamingXie.github.io%2F2018%2F08%2F06%2F%E8%82%A1%E5%B8%82%E8%A7%82%E5%AF%9F%E6%97%A5%E8%AE%B0180806%2F</url>
    <content type="text"><![CDATA[今天的大盘依然是非常惨烈。已破两年半最低点，之后可能会到三年最低点。 基建、金融股走势还算健康，还有上涨空间。 其实这一波指数应该已经跌到位了，但是看白马股还完全没有停下来的意思。之后估计会有一段时间的杀跌和超跌。 8月底出年报，如果收益及增长符合预期，那么可以止跌。如果收益不符合预期，那么还要继续下跌。]]></content>
      <categories>
        <category>股市观察日记</category>
      </categories>
      <tags>
        <tag>Stock Analysis</tag>
        <tag>Technical Analysis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[股市观察日记180802]]></title>
    <url>%2FJiamingXie.github.io%2F2018%2F08%2F02%2F%E8%82%A1%E5%B8%82%E8%A7%82%E5%AF%9F%E6%97%A5%E8%AE%B0180802%2F</url>
    <content type="text"><![CDATA[通常情况下，只要上涨放量回调缩量，上升趋势就能够得以延续；如果与之相反，回调放量上涨却缩量，就应该谨慎对待了。 缩量上涨期间应该卖出股票锁定部分利润。 上升期的后期的股价大幅下跌后往往会有反弹，这可能是更大更活跃卖盘将持续出现的一个迹象。 在1的位置大盘见顶 2的位置大盘见底]]></content>
      <categories>
        <category>股市观察日记</category>
      </categories>
      <tags>
        <tag>Stock Analysis</tag>
        <tag>Technical Analysis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[股市观察日记180801]]></title>
    <url>%2FJiamingXie.github.io%2F2018%2F08%2F01%2F%E8%82%A1%E5%B8%82%E8%A7%82%E5%AF%9F%E6%97%A5%E8%AE%B0180801%2F</url>
    <content type="text"><![CDATA[今天的早盘走势和前天非常像 两天很少会有一模一样的走势，所以尾盘会和之前的反着走，有一个加速下跌的过程. 顶部正式确认，开始回调，所以尾盘不是买入机会，要等机会。 果然不出所料，尾盘下跌。]]></content>
      <categories>
        <category>股市观察日记</category>
      </categories>
      <tags>
        <tag>Stock Analysis</tag>
        <tag>Technical Analysis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[股市观察日记180731]]></title>
    <url>%2FJiamingXie.github.io%2F2018%2F07%2F31%2F%E8%82%A1%E5%B8%82%E8%A7%82%E5%AF%9F%E6%97%A5%E8%AE%B0180731%2F</url>
    <content type="text"><![CDATA[大盘 上证指数 差不多已经调整到位了，早上把昨天尾盘拉升的部分消化掉了，低点是进场机会。 创业板 反弹的意愿很强烈。 个股 概念股 低位没有筹码，换手率高 没有业绩，MACD背离，必定跌破最低点]]></content>
      <categories>
        <category>股市观察日记</category>
      </categories>
      <tags>
        <tag>Stock Analysis</tag>
        <tag>Technical Analysis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[股市观察日记180726]]></title>
    <url>%2FJiamingXie.github.io%2F2018%2F07%2F26%2F%E8%82%A1%E5%B8%82%E8%A7%82%E5%AF%9F%E6%97%A5%E8%AE%B0180726%2F</url>
    <content type="text"><![CDATA[大盘 创业板只欠一跌 ，预计会拉一根比较长的下影线，最低点出现在上午。 看期指，IF（沪深300）创下最低点但是IC（中证500）已经止跌了，说明会优先弹起。 今天的大盘弱震荡收盘，预计明天也不会太强，向上微微收阳。 个股 300144 今天会拉一根下影线收在5日均线上，洗盘，让昨天没有跑掉的人今天跑掉。如果没有拉出下影线走势就非常不健康了，可能要跌到20日均线位置。 前天下拉，踩五日线，昨天上攻失败，今天往下再踩一下，确认。之后向上突破。]]></content>
      <categories>
        <category>股市观察日记</category>
      </categories>
      <tags>
        <tag>Stock Analysis</tag>
        <tag>Technical Analysis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[股市观察日记180725]]></title>
    <url>%2FJiamingXie.github.io%2F2018%2F07%2F25%2F%E8%82%A1%E5%B8%82%E8%A7%82%E5%AF%9F%E6%97%A5%E8%AE%B0180725%2F</url>
    <content type="text"><![CDATA[今天的医疗股非常强势。 创业板，缺根儿阴线，之后反弹。 下面来比对两只涨势都非常不错的股票. 这只股一开始就拉上来将近7个点，后续有些许乏力 通策医疗的走势则更加健康，今天有希望涨停。]]></content>
      <categories>
        <category>股市观察日记</category>
      </categories>
      <tags>
        <tag>Stock Analysis</tag>
        <tag>Technical Analysis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[股市观察日记180724]]></title>
    <url>%2FJiamingXie.github.io%2F2018%2F07%2F24%2F%E8%82%A1%E5%B8%82%E8%A7%82%E5%AF%9F%E6%97%A5%E8%AE%B0180724%2F</url>
    <content type="text"><![CDATA[大盘 大盘连涨3天，第一天是金融股涨的，第二天是金融和基建涨的，第三天是基建涨的。 保险、券商优先开始回调。 到34.14左右量都放出来，其实跌得差不多了。 明日走势预测 不会马上下跌，可能要先横一下然后再下跌。 个股 东方财富依旧很强，最多往回踩一下补上缺口，之后就会上涨。 成都路桥，连板四天，之后可以挂单排队，只要开板买进，之后看到7.3+抛出 换手率日渐升高的妖股要非常小心，不可以买入 前几天因为资金流出一直在跌的美的、格力、五粮液、贵州茅台等白马股开始有资金流入上涨。 从前一天的情况可以看出一二，尾盘放量拉升了。]]></content>
      <categories>
        <category>股市观察日记</category>
      </categories>
      <tags>
        <tag>Stock Analysis</tag>
        <tag>Technical Analysis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[股市观察日记180723]]></title>
    <url>%2FJiamingXie.github.io%2F2018%2F07%2F23%2F%E8%82%A1%E5%B8%82%E8%A7%82%E5%AF%9F%E6%97%A5%E8%AE%B0180723%2F</url>
    <content type="text"><![CDATA[基本知识 如果一支股票的的卖盘很多但是卖盘很少，但是股价却不怎么下跌，则说明这支股票会上涨。 大盘&amp;个股 把成都银行拉了一个板，其他银行股跟着涨，拉动大盘上升，其他个股都没什么动静。 量在早上放出来了，换手率有25%（妖股一般都是早上放量） 这是一支比较典型的突破股。]]></content>
      <categories>
        <category>股市观察日记</category>
      </categories>
      <tags>
        <tag>Stock Analysis</tag>
        <tag>Technical Analysis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[股市观察日记180720]]></title>
    <url>%2FJiamingXie.github.io%2F2018%2F07%2F20%2F%E8%82%A1%E5%B8%82%E8%A7%82%E5%AF%9F%E6%97%A5%E8%AE%B0180720%2F</url>
    <content type="text"><![CDATA[大盘 今天的大盘以震荡为主，人民币跌破6.8。 今天的盘面非常少见，下午开始上拉金融股。 保险是龙头，新华保险是龙头里的龙头。保险是最早开始反弹的板块，日线级别也还有上升空间。 *如何看龙头股是否适合追涨？ 今天的领涨板块是软件、电子信息。 首先股票和大盘都得有上涨空间，【分时】其次是看到大盘、股票在无量回调的时候（下跌但是没有量），就说明可以买入了。 个股 东方财富 这支股票可以考虑逢低买入。 现在一直在横走震荡，形成了一个三角形，之后非常有可能向上突破。是创业板的领头股票。 上午才说要突破呢，下午就突破了。]]></content>
      <categories>
        <category>股市观察日记</category>
      </categories>
      <tags>
        <tag>Stock Analysis</tag>
        <tag>Technical Analysis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[股市观察日记180719]]></title>
    <url>%2FJiamingXie.github.io%2F2018%2F07%2F19%2F%E8%82%A1%E5%B8%82%E8%A7%82%E5%AF%9F%E6%97%A5%E8%AE%B0180719%2F</url>
    <content type="text"><![CDATA[大盘 今天的走势比较健康，早上涨了一下该跌就跌下去了，预计下午踩一下2768~2770点位，之后反弹。 之前几天一直在回调，把五天前的那根大阳线调整回去了，是比较好的买入时机。 下午13：20分左右，期货指数创了一个新低，但是指数没有创新低，这是一个底部信号。 个股 风华高科000636 这只股虽然是妖股，但是基本面不错。 有一个小的窗口，把窗口封上以后下跌到低点是买点。 前一天跌，消耗多方能量，今天早上多方能量耗尽（量放出来了但是股价变化不大），可以考虑大概到21.4的位置进场。 一心堂002727 这只股的走势比较理想 大盘跌，它也跟着跌，但是先于大盘弹起了。 买点的位置在32.92到33.09之间，10日线33左右，之后如果跟着大盘再跌一下就低点买进，否则就应该直接买进。 东方财富300059 创业板大跌的时候依旧非常强势，是有可能带领创业板反弹的龙头股，长线依旧看好。 600009上海机场 十日均线60.26，马上要到了；bias也下来了；MACD背离；是买入时机。 601888中国国旅 早上有两个卖点，长线可以布局，短线还需观察。]]></content>
      <categories>
        <category>股市观察日记</category>
      </categories>
      <tags>
        <tag>Stock Analysis</tag>
        <tag>Technical Analysis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[股市观察日记180718]]></title>
    <url>%2FJiamingXie.github.io%2F2018%2F07%2F18%2F%E8%82%A1%E5%B8%82%E8%A7%82%E5%AF%9F%E6%97%A5%E8%AE%B0180718%2F</url>
    <content type="text"><![CDATA[基本知识 期货交易： IF 沪深300 IH 上证50 IC 中证500 看好权重股但是不知道大盘走势的情况下可以做多上证50，做空沪深300 大盘 今天的大盘走势非常不健康，早上三次试图突破都失败了。下午的一次向上冲刺是诱多，之后就开始下跌（一般这种行情之后都是一个大阴），大概回调到昨天均线的位置。 调整结束后是买入时机。 预计大盘明天会继续下跌，今天早上的多头力量没有放干净，下跌位置大概在5天前开盘的位置2770左右，如果跌破的话非常不乐观，未跌破的话可以考虑抄底。 个股 北方华创 前两天形成双顶（短线），之后的走势应该会向下突破。]]></content>
      <categories>
        <category>股市观察日记</category>
      </categories>
      <tags>
        <tag>Stock Analysis</tag>
        <tag>Technical Analysis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[股市观察日记180717]]></title>
    <url>%2FJiamingXie.github.io%2F2018%2F07%2F17%2F%E8%82%A1%E5%B8%82%E8%A7%82%E5%AF%9F%E6%97%A5%E8%AE%B0180717%2F</url>
    <content type="text"><![CDATA[上午 这里是一个机会，但是并不知道大盘后市会怎么走，所以买入的话会有一定风险。 国旅（601888）和机场（600009）的乖离率BIAS太高了，不宜入场，可以回调以后入场。 下午 横盘了，横得越久越危险。大家都是被套了不愿意走。 第三天了，一旦股民开始止损，会有一个稍大幅的下跌，然后再上升，表示量放干净了。 短期内（至少五天），大盘不会出现一模一样的走势，昨天是下+横，今天应该不会是下+横。 从日线看是一个短期的顶部。观察一下昨天涨的板块，消费、医药等，今天都在跌，这是一个回调的过程；但是昨天跌的板块，今天也没涨起来，所以今天整体是一个下跌的态势。之后强势的股可能会反弹。 今天的底部差不多是四天前阳线的开盘价，大家都在等这个底部，没有跌下去，之后反弹加速的时候就应该意识到可以追涨了。 基本知识 追涨的时候要关注龙头股，去看五分钟涨跌幅榜里面的股票。 还可以关注的股票有“挖坑的股票”，两点的这个坑是哪支股票挖出来的，还得填回去。 绿线完全放完的时候可以进场。 也可以关注一些走势和大盘向逆的股票。大盘下跌之前已经起来了，说明比较强势。 昨天跌但是今天不跌的股票，明天很有可能会上涨，因为今天大盘跌了，它却没有跌，那么明天如果大盘不跌，它就会上涨。比如说保险板块今天是横盘，表现比大盘好，是被大盘拖累的。]]></content>
      <categories>
        <category>股市观察日记</category>
      </categories>
      <tags>
        <tag>Stock Analysis</tag>
        <tag>Technical Analysis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[股市观察日记180716]]></title>
    <url>%2FJiamingXie.github.io%2F2018%2F07%2F16%2F%E8%82%A1%E5%B8%82%E8%A7%82%E5%AF%9F%E6%97%A5%E8%AE%B0180716%2F</url>
    <content type="text"><![CDATA[大盘走势分析 上周周五是一个弱震荡，今天是一个分化的走势，强者走强，弱者走弱。主要是权重股在跌，资金流出最多的是权重股（银行、保险、房地产等等）。 此时的交易策略是涨了卖出，跌了买入。 今天大盘跌到2804的位置反弹了，之后一定会有一个上涨出货的过程。整体来说走势还是比较弱的。 上午 大盘上午走出V形走势。 大约10点50分时开始反弹 行业龙头股（涨势较好）的股票可以看准买入时机 。 宋城演艺上午的时候逆势上涨，10点26分开始随着大盘回调，到10点52分左右到达低点，是一个买入机会。 从交易量来看放量很健康，上午的交易量已经和之前一整天的相当。 对于其他的龙头股也可以用相同的方法操作。 如何判断大盘要反弹了？ 信号一：出现背离了，MACD底部向上，但是股价下跌。 信号二：看领跌的股票何时止跌。 从之前的vol可以看出量没有放完，后面继续放量，但是股价没有再继续下跌了，说明跌不动了。 信号三：看期指会更明显。（期指的反应一般比较早） 开盘的时候往上冲了五格左右，之后向下跌的速度明显比较小，跌到五格的时候大概就可以判断已经跌不动了，是反弹的信号。 此时挑选一些涨势比较强的，逆势上涨的股票买入（大盘下跌时是机会），宋城演艺、珀莱雅等。 大盘走势分析 上周周五是一个弱震荡，今天是一个分化的走势，强者走强，弱者走弱。主要是权重股在跌，资金流出最多的是权重股（银行、保险、房地产等等）。 此时的交易策略是涨了卖出，跌了买入。 今天大盘跌到2804的位置反弹了，之后一定会有一个上涨出货的过程。整体来说走势还是比较弱的。 明日预测 现在大盘走向非常像一个喇叭口，多空势均力敌，当有一个新消息进来以后平衡会被打破。 预测明天会跌到2790左右的位置。 如果明天指数可以在半个小时到一个小时内恢复到2821左右，即前两天被套的人全部解套，那么大盘明天可能走出上涨的趋势，否则前两天的人会选择止损跑路，那么大盘会继续下跌。 基本知识 下单的时候要时刻紧盯盘口动向，如果有比较明显的大单砸盘，想快人一步的话就必须先下手往更低的位置挂一档。 如果有比较突然的上涨或者下跌，要快速撤单并重新挂单。 个股 突然下跌但是DDX非常健康，MACD也形成金叉，交易量不大，是买入的机会.]]></content>
      <categories>
        <category>股市观察日记</category>
      </categories>
      <tags>
        <tag>Stock Analysis</tag>
        <tag>Technical Analysis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[股市观察日记180712]]></title>
    <url>%2FJiamingXie.github.io%2F2018%2F07%2F12%2F%E8%82%A1%E5%B8%82%E8%A7%82%E5%AF%9F%E6%97%A5%E8%AE%B0180712%2F</url>
    <content type="text"><![CDATA[上行反弹点位预测 2850，若冲破2850则有可能冲击2900，否则会回调。]]></content>
      <categories>
        <category>股市观察日记</category>
      </categories>
      <tags>
        <tag>Stock Analysis</tag>
        <tag>Technical Analysis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[股市观察日记180711]]></title>
    <url>%2FJiamingXie.github.io%2F2018%2F07%2F11%2F%E8%82%A1%E5%B8%82%E8%A7%82%E5%AF%9F%E6%97%A5%E8%AE%B0180711%2F</url>
    <content type="text"><![CDATA[昨天还在讨论反弹到什么点位的问题，今天就开始暴跌。 上证A股低开2%。 美国对中国征收2000亿美元商品的关税的消息被封锁了，所以很多人都不知道。 股吧里到处都是一脸懵逼的群众，券商的报告也都是在讨论筑底反弹的问题。 9点钟 CN00Y（外资交易中国的指数）开盘暴跌。 9点15分A股开始挂单，暴跌。机构提早知道消息，都在出货了。 表现比较好的只有贵金属板块（避险资产） 。]]></content>
      <categories>
        <category>股市观察日记</category>
      </categories>
      <tags>
        <tag>Stock Analysis</tag>
        <tag>Technical Analysis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[股市观察日记180710]]></title>
    <url>%2FJiamingXie.github.io%2F2018%2F07%2F10%2F%E8%82%A1%E5%B8%82%E8%A7%82%E5%AF%9F%E6%97%A5%E8%AE%B0180710%2F</url>
    <content type="text"><![CDATA[经过7月9日的普涨以后开始下跌。 预计本周冲刺2850点，若无法冲刺则会继续下跌。 下午回弹收在2827。 多方动能未释放干净，下一阶段（两天）可能冲高至2850后回落。]]></content>
      <categories>
        <category>股市观察日记</category>
      </categories>
      <tags>
        <tag>Stock Analysis</tag>
        <tag>Technical Analysis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[股市观察日记180709]]></title>
    <url>%2FJiamingXie.github.io%2F2018%2F07%2F09%2F%E8%82%A1%E5%B8%82%E8%A7%82%E5%AF%9F%E6%97%A5%E8%AE%B0180709%2F</url>
    <content type="text"><![CDATA[中航沈飞 600760 分时DDX可以看出来在出货，一直在出（持有股票的人先出了一部分。因为大盘比较好所以拉起来了一些，但是其实还是在出货 。预测第二天会冲高回落（冲一个短期的新高）【钓鱼线】 海特高新 这两兄弟比较像，海特高新也是尾盘时拉升一下，第二天冲短期新高，冲高回落。 但是分时DDX一直在出货。 两支股票都有比较明显的背离。]]></content>
      <categories>
        <category>股市观察日记</category>
      </categories>
      <tags>
        <tag>Stock Analysis</tag>
        <tag>Technical Analysis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[股市观察日记180706]]></title>
    <url>%2FJiamingXie.github.io%2F2018%2F07%2F06%2F%E8%82%A1%E5%B8%82%E8%A7%82%E5%AF%9F%E6%97%A5%E8%AE%B0180706%2F</url>
    <content type="text"><![CDATA[基本知识 内外盘： 外盘：买盘比较积极 内盘：抛盘比较积极 卖单量一般比买单的量要大（除了一些涨得很多的股） 挂单的时候要有一些技巧，卖一挂的38.60，还是一单几百手的大单，那么就要挂38.59的，抢先交易。 个股 中航沈飞：比较明显的背离，该卖了。（股价创新高但是MACD下行）虽然涨不动了，但是也不太跌得下去。 东方财富300059： 这只股很强，大盘下跌的时候逆势上扬。下一个回调的时候是买入时机，它是反弹的龙头股。]]></content>
      <categories>
        <category>股市观察日记</category>
      </categories>
      <tags>
        <tag>Stock Analysis</tag>
        <tag>Technical Analysis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[股市观察日记180704]]></title>
    <url>%2FJiamingXie.github.io%2F2018%2F07%2F04%2F%E8%82%A1%E5%B8%82%E8%A7%82%E5%AF%9F%E6%97%A5%E8%AE%B0180704%2F</url>
    <content type="text"><![CDATA[基本知识 筹码表示成交的位置，在该价位成交的量越大，筹码图越高。 筹码较小的位置是比较容易破位的点，需要多加注意。 行业内龙头股之间可能会有非常强的相互作用。一支股票的破位很有可能导致另一只股票也破位（虽然从其他指标判断可能已经跌到底了） 一句话总结 今天的股市大盘不太好，也没有热点。]]></content>
      <categories>
        <category>股市观察日记</category>
      </categories>
      <tags>
        <tag>Stock Analysis</tag>
        <tag>Technical Analysis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[股市观察日记180703]]></title>
    <url>%2FJiamingXie.github.io%2F2018%2F07%2F03%2F%E8%82%A1%E5%B8%82%E8%A7%82%E5%AF%9F%E6%97%A5%E8%AE%B0180703%2F</url>
    <content type="text"><![CDATA[基本知识 成交量很大但是价格变化不大的时候，说明跌不动了，有人接盘，是买入的信号。 早上开盘半个小时，美的的成交量已经比前两天一整天的都多了，说明跌不动了。 5分钟涨跌幅可以说明盘口的情况。 洗盘：一般出现在股价V型底端，群众恐慌而大量抛售股票，洗掉一大堆不坚定的人。 盘面分析 上午 因为之前涨得比较多，所以现在大盘股在调整（下跌） 创业板块已经跌得差不多了，这几天行情还可以，在慢慢上升中，今天有望收红。 今天的领跌行业是民航、酿酒、家电，都是之前涨得比较多的行业。 创业板和大盘的走势非常相似，但是从大概6月20日开始，创业板开始上升，大盘还在下跌。 图为上证指数，从趋势线可以看出，差不多已经跌到底了（2722左右） 预计创业板会率先开始反弹，下午可以期待一下创业板的龙头股卫宁健康（300253） 在今天之前这只股的涨幅是 涨停 调整。 11:17分左右跟着指数跌了一下，但是量不大，之后开始拉升，下午有希望冲一下【最后没冲上去】 下午 领跌：民航、酿酒、珠宝 券商信托、保险上拉，银行不尴不尬 金融、非银金融： 中信证券、工商银行、建设银行、招商银行、交通银行、浦发银行拉升比较明显 传媒板块拉升：元隆雅图、金逸影视、北京文化涨停。其他传媒股也有比较大的拉升 大盘呈现V型反弹 没有跌破底，且与MACD线出现背离，显示见底的信号，若之后破底的话不好说。白马股补跌严重。 创业板下午爆发三波，最后半个小时有所回落，是爆发的尽头的信号。 创业板指与大盘在下午有脱离的趋势。 个股： 601336 新华保险：保险是今天反弹最早的一个行业 11：20分左右下跌也未跌破最低线，大机构更加倾向于上拉这些股票 。 002371 北方华创：叠加相同行业其他股票后可以发现其他股跟涨这只股票 600760 中航沈飞 关注创业板的领涨股票（下午涨停的股票），基本上相关行业的其他股票都是跟涨这些领涨股。发现特征以后后续可以追涨。 后续： 后续的大盘还需要观望，若不跌破底，则有望反弹，虽然反弹力度并不会很大。 期待一下7月6日川普搞事会对股票造成多大影响。若出台文件比较符合人的预期，那么股市将不会继续下跌。 今天的行情整体上还是比较符合预期的。]]></content>
      <categories>
        <category>股市观察日记</category>
      </categories>
      <tags>
        <tag>Stock Analysis</tag>
        <tag>Technical Analysis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[股市观察日记180702]]></title>
    <url>%2FJiamingXie.github.io%2F2018%2F07%2F02%2F%E8%82%A1%E5%B8%82%E8%A7%82%E5%AF%9F%E6%97%A5%E8%AE%B0180702%2F</url>
    <content type="text"><![CDATA[模拟交易的第一天，暴跌……可能是上天的安排…… 但是股票交易员的任务就是把规定量的股票交易完，所以减少损失很重要。 基本知识 9点15到9点25集合竞价，20分以后禁止撤单，所以一般只看20分以后的单子即可 应该关注的指标： 期指：一般期货指数会比大盘要快一点，因为不需要实物交易，两者走势一般相同 个股： 看行业的走势 看大盘的走势 看行业龙头的走势 本身在前两天的顶和底 交易量：看交易量判断是否是好的买入或卖出时机。如果之前有大量的卖出交易，而此刻的卖出交易量小于之前的量，说明可能还没有见底；如果此刻卖出量是最大的，那么是比较好的进场时机。 图为美的(000333)，2点左右的时候卖出量达到最高，是比较好的买入时机，后续有一个小的反弹。 图为工行（601398） 反弹：一般一次反弹回三分之一到二分之一是比较强劲的，BOLL线收拢后一般会有一次比较大的反弹。 背离：如果股价与其他指标（如MACD线，分时DDX）出现背离，即一个顶点趋势与另一个顶点趋势相反，那么可以预测见底或者见顶，一般两到三个为信号。 *分时DDX表示大单的交易数量 日内操作t+0：（只在有仓位时操作） 做t：当天看好某只股票，在开盘时买入，收盘时卖出，可以保持仓位不变；看跌某只股票，在开盘时卖出，收盘时买入。 倒t：当天若看走眼了要迅速割肉离场，以防损失扩大。 中报预披露早的股票 000818 、002240 、002462 、002565 、300001 、603199 中报预披露时间比较早，大盘跌的情况下这6只股票均上涨 比较明显的特征是：集中竞价的时候大家都涨停，然后撤单，最后都是高开（相比前一天） 大盘概览 上证指数跌至2775.56，不会是本周的最低值。 所有行业全线收跌，形势较好的有酿酒行业、医疗行业（跌得比较少） 。 跌得最严重的行业是保险、钢铁、煤炭、券商银行等 。]]></content>
      <categories>
        <category>股市观察日记</category>
      </categories>
      <tags>
        <tag>Stock Analysis</tag>
        <tag>Technical Analysis</tag>
      </tags>
  </entry>
</search>
